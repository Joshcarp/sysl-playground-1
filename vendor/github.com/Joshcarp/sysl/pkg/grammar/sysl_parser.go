// Generated from pkg/grammar/SyslParser.g4 by ANTLR 4.7.

package parser // SyslParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 146, 1667,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 3, 2, 3, 2, 3, 2, 3, 2, 7, 2, 357,
	10, 2, 12, 2, 14, 2, 360, 11, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 366, 10,
	3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 6, 5, 375, 10, 5, 13, 5, 14,
	5, 376, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 7, 8, 388,
	10, 8, 12, 8, 14, 8, 391, 11, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 7,
	9, 399, 10, 9, 12, 9, 14, 9, 402, 11, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 5, 10, 411, 10, 10, 3, 11, 3, 11, 5, 11, 415, 10, 11, 3,
	12, 3, 12, 3, 12, 3, 12, 7, 12, 421, 10, 12, 12, 12, 14, 12, 424, 11, 12,
	3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 5, 14, 433, 10, 14, 3,
	15, 3, 15, 5, 15, 437, 10, 15, 3, 16, 3, 16, 3, 16, 5, 16, 442, 10, 16,
	3, 17, 3, 17, 5, 17, 446, 10, 17, 3, 18, 3, 18, 3, 18, 5, 18, 451, 10,
	18, 3, 19, 3, 19, 5, 19, 455, 10, 19, 3, 20, 3, 20, 3, 20, 6, 20, 460,
	10, 20, 13, 20, 14, 20, 461, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 5, 21,
	469, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 6, 23, 478,
	10, 23, 13, 23, 14, 23, 479, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24,
	5, 24, 488, 10, 24, 5, 24, 490, 10, 24, 3, 24, 5, 24, 493, 10, 24, 3, 24,
	5, 24, 496, 10, 24, 3, 24, 3, 24, 5, 24, 500, 10, 24, 3, 25, 3, 25, 3,
	25, 3, 25, 5, 25, 506, 10, 25, 3, 25, 3, 25, 3, 26, 3, 26, 6, 26, 512,
	10, 26, 13, 26, 14, 26, 513, 3, 26, 3, 26, 3, 27, 3, 27, 5, 27, 520, 10,
	27, 3, 27, 3, 27, 3, 27, 5, 27, 525, 10, 27, 3, 27, 5, 27, 528, 10, 27,
	5, 27, 530, 10, 27, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 6, 29, 540, 10, 29, 13, 29, 14, 29, 541, 3, 29, 3, 29, 3, 30, 5, 30,
	547, 10, 30, 3, 30, 3, 30, 3, 30, 5, 30, 552, 10, 30, 3, 31, 7, 31, 555,
	10, 31, 12, 31, 14, 31, 558, 11, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32,
	7, 32, 565, 10, 32, 12, 32, 14, 32, 568, 11, 32, 3, 32, 3, 32, 3, 32, 5,
	32, 573, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 6, 32,
	582, 10, 32, 13, 32, 14, 32, 583, 3, 32, 5, 32, 587, 10, 32, 3, 33, 3,
	33, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 7, 35, 596, 10, 35, 12, 35, 14,
	35, 599, 11, 35, 3, 36, 3, 36, 5, 36, 603, 10, 36, 3, 36, 5, 36, 606, 10,
	36, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 615, 10, 38,
	6, 38, 617, 10, 38, 13, 38, 14, 38, 618, 3, 38, 3, 38, 3, 39, 3, 39, 3,
	39, 5, 39, 626, 10, 39, 3, 40, 7, 40, 629, 10, 40, 12, 40, 14, 40, 632,
	11, 40, 3, 40, 3, 40, 3, 40, 3, 40, 6, 40, 638, 10, 40, 13, 40, 14, 40,
	639, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 5, 42, 653, 10, 42, 3, 42, 5, 42, 656, 10, 42, 3, 43, 3, 43,
	3, 43, 3, 43, 7, 43, 662, 10, 43, 12, 43, 14, 43, 665, 11, 43, 3, 44, 3,
	44, 5, 44, 669, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45,
	677, 10, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 686,
	10, 47, 3, 48, 3, 48, 6, 48, 690, 10, 48, 13, 48, 14, 48, 691, 5, 48, 694,
	10, 48, 3, 49, 3, 49, 3, 49, 7, 49, 699, 10, 49, 12, 49, 14, 49, 702, 11,
	49, 3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 52, 3, 52, 3, 53, 3, 53, 6, 53,
	713, 10, 53, 13, 53, 14, 53, 714, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 721,
	10, 53, 5, 53, 723, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 729, 10,
	54, 12, 54, 14, 54, 732, 11, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3,
	55, 5, 55, 740, 10, 55, 3, 55, 3, 55, 5, 55, 744, 10, 55, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 7, 56, 751, 10, 56, 12, 56, 14, 56, 754, 11, 56, 3,
	56, 3, 56, 3, 57, 3, 57, 5, 57, 760, 10, 57, 3, 57, 3, 57, 3, 57, 7, 57,
	765, 10, 57, 12, 57, 14, 57, 768, 11, 57, 3, 57, 3, 57, 3, 58, 3, 58, 7,
	58, 774, 10, 58, 12, 58, 14, 58, 777, 11, 58, 3, 59, 3, 59, 3, 59, 3, 59,
	3, 59, 7, 59, 784, 10, 59, 12, 59, 14, 59, 787, 11, 59, 3, 59, 3, 59, 3,
	60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61, 6, 61, 797, 10, 61, 13, 61, 14,
	61, 798, 3, 61, 3, 61, 3, 62, 6, 62, 804, 10, 62, 13, 62, 14, 62, 805,
	3, 63, 5, 63, 809, 10, 63, 3, 63, 3, 63, 3, 63, 6, 63, 814, 10, 63, 13,
	63, 14, 63, 815, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 6, 64, 824,
	10, 64, 13, 64, 14, 64, 825, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65,
	3, 65, 5, 65, 835, 10, 65, 3, 65, 5, 65, 838, 10, 65, 3, 66, 3, 66, 3,
	66, 3, 67, 3, 67, 5, 67, 845, 10, 67, 3, 68, 3, 68, 3, 68, 7, 68, 850,
	10, 68, 12, 68, 14, 68, 853, 11, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 868, 10,
	70, 3, 70, 5, 70, 871, 10, 70, 3, 71, 3, 71, 5, 71, 875, 10, 71, 3, 71,
	5, 71, 878, 10, 71, 3, 71, 5, 71, 881, 10, 71, 3, 71, 3, 71, 3, 71, 6,
	71, 886, 10, 71, 13, 71, 14, 71, 887, 3, 71, 3, 71, 3, 72, 3, 72, 3, 73,
	3, 73, 3, 73, 5, 73, 897, 10, 73, 3, 73, 5, 73, 900, 10, 73, 3, 73, 5,
	73, 903, 10, 73, 3, 73, 3, 73, 3, 73, 3, 73, 6, 73, 909, 10, 73, 13, 73,
	14, 73, 910, 3, 73, 3, 73, 5, 73, 915, 10, 73, 5, 73, 917, 10, 73, 3, 74,
	3, 74, 5, 74, 921, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 6, 74, 927, 10,
	74, 13, 74, 14, 74, 928, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75,
	937, 10, 75, 3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 943, 10, 76, 12, 76, 14,
	76, 946, 11, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78,
	3, 78, 5, 78, 957, 10, 78, 3, 79, 3, 79, 6, 79, 961, 10, 79, 13, 79, 14,
	79, 962, 3, 79, 5, 79, 966, 10, 79, 3, 80, 3, 80, 3, 80, 3, 81, 3, 81,
	3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3,
	85, 3, 85, 3, 85, 3, 85, 5, 85, 987, 10, 85, 3, 85, 3, 85, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 6, 86, 996, 10, 86, 13, 86, 14, 86, 997, 3, 86, 3,
	86, 5, 86, 1002, 10, 86, 3, 87, 3, 87, 3, 87, 5, 87, 1007, 10, 87, 3, 87,
	5, 87, 1010, 10, 87, 3, 87, 3, 87, 3, 87, 3, 87, 6, 87, 1016, 10, 87, 13,
	87, 14, 87, 1017, 3, 87, 3, 87, 5, 87, 1022, 10, 87, 3, 88, 3, 88, 3, 88,
	3, 88, 5, 88, 1028, 10, 88, 3, 88, 3, 88, 3, 88, 3, 88, 6, 88, 1034, 10,
	88, 13, 88, 14, 88, 1035, 3, 88, 3, 88, 5, 88, 1040, 10, 88, 3, 89, 3,
	89, 5, 89, 1044, 10, 89, 3, 90, 3, 90, 3, 91, 3, 91, 5, 91, 1050, 10, 91,
	3, 91, 3, 91, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 7, 93, 1059, 10, 93, 12,
	93, 14, 93, 1062, 11, 93, 3, 94, 3, 94, 3, 94, 5, 94, 1067, 10, 94, 3,
	94, 3, 94, 3, 95, 3, 95, 5, 95, 1073, 10, 95, 3, 96, 3, 96, 3, 96, 7, 96,
	1078, 10, 96, 12, 96, 14, 96, 1081, 11, 96, 3, 97, 3, 97, 3, 97, 3, 97,
	3, 97, 5, 97, 1088, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3,
	98, 3, 98, 3, 98, 5, 98, 1099, 10, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99,
	3, 99, 3, 100, 3, 100, 5, 100, 1109, 10, 100, 3, 101, 3, 101, 3, 101, 3,
	101, 3, 101, 5, 101, 1116, 10, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3,
	102, 3, 103, 3, 103, 3, 103, 5, 103, 1126, 10, 103, 3, 103, 3, 103, 3,
	103, 3, 104, 3, 104, 3, 104, 3, 104, 3, 104, 3, 105, 3, 105, 3, 106, 3,
	106, 3, 107, 3, 107, 3, 108, 5, 108, 1143, 10, 108, 3, 108, 3, 108, 3,
	109, 5, 109, 1148, 10, 109, 3, 109, 3, 109, 5, 109, 1152, 10, 109, 3, 109,
	3, 109, 3, 109, 5, 109, 1157, 10, 109, 3, 110, 3, 110, 3, 110, 3, 110,
	5, 110, 1163, 10, 110, 3, 111, 3, 111, 3, 111, 3, 111, 7, 111, 1169, 10,
	111, 12, 111, 14, 111, 1172, 11, 111, 3, 111, 3, 111, 3, 112, 5, 112, 1177,
	10, 112, 3, 112, 3, 112, 5, 112, 1181, 10, 112, 3, 112, 3, 112, 3, 112,
	3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113,
	3, 113, 3, 113, 5, 113, 1197, 10, 113, 3, 114, 3, 114, 3, 115, 3, 115,
	3, 115, 7, 115, 1204, 10, 115, 12, 115, 14, 115, 1207, 11, 115, 3, 116,
	3, 116, 3, 116, 3, 116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118, 1226, 10,
	118, 3, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1232, 10, 119, 3, 120, 3,
	120, 3, 121, 3, 121, 3, 121, 3, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3,
	123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 1252,
	10, 123, 3, 124, 3, 124, 7, 124, 1256, 10, 124, 12, 124, 14, 124, 1259,
	11, 124, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 5, 126, 1266, 10, 126,
	3, 127, 5, 127, 1269, 10, 127, 3, 127, 3, 127, 3, 128, 3, 128, 3, 128,
	3, 129, 3, 129, 7, 129, 1278, 10, 129, 12, 129, 14, 129, 1281, 11, 129,
	3, 130, 3, 130, 3, 130, 3, 131, 3, 131, 7, 131, 1288, 10, 131, 12, 131,
	14, 131, 1291, 11, 131, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3, 133,
	7, 133, 1299, 10, 133, 12, 133, 14, 133, 1302, 11, 133, 3, 134, 3, 134,
	3, 134, 7, 134, 1307, 10, 134, 12, 134, 14, 134, 1310, 11, 134, 3, 135,
	3, 135, 3, 135, 7, 135, 1315, 10, 135, 12, 135, 14, 135, 1318, 11, 135,
	3, 136, 3, 136, 3, 136, 7, 136, 1323, 10, 136, 12, 136, 14, 136, 1326,
	11, 136, 3, 137, 3, 137, 3, 137, 7, 137, 1331, 10, 137, 12, 137, 14, 137,
	1334, 11, 137, 3, 138, 3, 138, 3, 138, 7, 138, 1339, 10, 138, 12, 138,
	14, 138, 1342, 11, 138, 3, 139, 3, 139, 3, 139, 7, 139, 1347, 10, 139,
	12, 139, 14, 139, 1350, 11, 139, 3, 140, 3, 140, 3, 140, 7, 140, 1355,
	10, 140, 12, 140, 14, 140, 1358, 11, 140, 3, 141, 3, 141, 5, 141, 1362,
	10, 141, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141, 3, 142, 3, 142, 3, 142,
	3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 7, 144, 1377, 10, 144, 12, 144,
	14, 144, 1380, 11, 144, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 5, 145,
	1387, 10, 145, 3, 146, 3, 146, 3, 146, 3, 146, 5, 146, 1393, 10, 146, 3,
	147, 3, 147, 3, 147, 3, 148, 5, 148, 1399, 10, 148, 3, 148, 3, 148, 3,
	148, 3, 148, 6, 148, 1405, 10, 148, 13, 148, 14, 148, 1406, 3, 148, 5,
	148, 1410, 10, 148, 3, 148, 3, 148, 3, 149, 3, 149, 3, 149, 3, 149, 3,
	149, 5, 149, 1419, 10, 149, 3, 150, 3, 150, 3, 150, 3, 150, 5, 150, 1425,
	10, 150, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 5, 151,
	1434, 10, 151, 3, 152, 3, 152, 3, 152, 3, 152, 3, 153, 3, 153, 3, 153,
	3, 153, 3, 153, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 155, 3, 155,
	3, 156, 3, 156, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157,
	3, 157, 3, 157, 5, 157, 1463, 10, 157, 3, 157, 3, 157, 5, 157, 1467, 10,
	157, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3, 159, 3, 159, 3, 159, 5,
	159, 1477, 10, 159, 3, 160, 3, 160, 3, 160, 5, 160, 1482, 10, 160, 3, 161,
	3, 161, 3, 162, 3, 162, 3, 163, 3, 163, 3, 164, 5, 164, 1491, 10, 164,
	3, 164, 3, 164, 3, 164, 3, 164, 3, 164, 5, 164, 1498, 10, 164, 3, 164,
	3, 164, 5, 164, 1502, 10, 164, 3, 164, 3, 164, 3, 164, 3, 164, 6, 164,
	1508, 10, 164, 13, 164, 14, 164, 1509, 3, 164, 3, 164, 3, 164, 3, 164,
	3, 165, 3, 165, 3, 165, 3, 165, 3, 166, 3, 166, 3, 166, 3, 166, 3, 167,
	3, 167, 3, 167, 7, 167, 1527, 10, 167, 12, 167, 14, 167, 1530, 11, 167,
	3, 168, 3, 168, 3, 169, 3, 169, 3, 169, 3, 169, 3, 169, 3, 169, 3, 169,
	5, 169, 1541, 10, 169, 3, 169, 5, 169, 1544, 10, 169, 3, 169, 3, 169, 3,
	169, 3, 169, 3, 169, 5, 169, 1551, 10, 169, 3, 170, 3, 170, 3, 170, 5,
	170, 1556, 10, 170, 3, 170, 3, 170, 7, 170, 1560, 10, 170, 12, 170, 14,
	170, 1563, 11, 170, 3, 170, 3, 170, 5, 170, 1567, 10, 170, 3, 170, 3, 170,
	7, 170, 1571, 10, 170, 12, 170, 14, 170, 1574, 11, 170, 3, 170, 3, 170,
	5, 170, 1578, 10, 170, 3, 170, 3, 170, 5, 170, 1582, 10, 170, 3, 171, 3,
	171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3,
	171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 6, 171, 1600, 10, 171, 13,
	171, 14, 171, 1601, 3, 171, 3, 171, 5, 171, 1606, 10, 171, 3, 172, 7, 172,
	1609, 10, 172, 12, 172, 14, 172, 1612, 11, 172, 3, 172, 3, 172, 3, 172,
	3, 172, 3, 173, 3, 173, 3, 173, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174,
	3, 174, 7, 174, 1627, 10, 174, 12, 174, 14, 174, 1630, 11, 174, 5, 174,
	1632, 10, 174, 3, 174, 7, 174, 1635, 10, 174, 12, 174, 14, 174, 1638, 11,
	174, 3, 174, 5, 174, 1641, 10, 174, 3, 174, 7, 174, 1644, 10, 174, 12,
	174, 14, 174, 1647, 11, 174, 3, 174, 5, 174, 1650, 10, 174, 3, 175, 6,
	175, 1653, 10, 175, 13, 175, 14, 175, 1654, 3, 176, 5, 176, 1658, 10, 176,
	3, 176, 6, 176, 1661, 10, 176, 13, 176, 14, 176, 1662, 3, 176, 3, 176,
	3, 176, 2, 2, 177, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
	30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64,
	66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100,
	102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130,
	132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,
	162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190,
	192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220,
	222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250,
	252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280,
	282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310,
	312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340,
	342, 344, 346, 348, 350, 2, 20, 4, 2, 63, 64, 141, 141, 4, 2, 44, 44, 142,
	142, 3, 2, 8, 9, 4, 2, 8, 9, 11, 11, 4, 2, 17, 19, 21, 23, 4, 2, 60, 60,
	63, 64, 4, 2, 118, 120, 136, 139, 4, 2, 88, 88, 142, 142, 5, 2, 5, 5, 135,
	135, 141, 141, 3, 2, 124, 125, 4, 2, 131, 131, 133, 133, 3, 2, 122, 123,
	4, 2, 76, 76, 141, 142, 5, 2, 97, 97, 100, 100, 102, 103, 4, 2, 98, 99,
	111, 111, 4, 2, 97, 97, 100, 100, 4, 2, 79, 80, 83, 84, 4, 2, 107, 107,
	109, 109, 2, 1738, 2, 352, 3, 2, 2, 2, 4, 361, 3, 2, 2, 2, 6, 369, 3, 2,
	2, 2, 8, 371, 3, 2, 2, 2, 10, 378, 3, 2, 2, 2, 12, 381, 3, 2, 2, 2, 14,
	383, 3, 2, 2, 2, 16, 394, 3, 2, 2, 2, 18, 405, 3, 2, 2, 2, 20, 414, 3,
	2, 2, 2, 22, 416, 3, 2, 2, 2, 24, 427, 3, 2, 2, 2, 26, 432, 3, 2, 2, 2,
	28, 436, 3, 2, 2, 2, 30, 438, 3, 2, 2, 2, 32, 445, 3, 2, 2, 2, 34, 447,
	3, 2, 2, 2, 36, 454, 3, 2, 2, 2, 38, 456, 3, 2, 2, 2, 40, 468, 3, 2, 2,
	2, 42, 470, 3, 2, 2, 2, 44, 475, 3, 2, 2, 2, 46, 489, 3, 2, 2, 2, 48, 501,
	3, 2, 2, 2, 50, 509, 3, 2, 2, 2, 52, 517, 3, 2, 2, 2, 54, 531, 3, 2, 2,
	2, 56, 533, 3, 2, 2, 2, 58, 546, 3, 2, 2, 2, 60, 556, 3, 2, 2, 2, 62, 566,
	3, 2, 2, 2, 64, 588, 3, 2, 2, 2, 66, 590, 3, 2, 2, 2, 68, 593, 3, 2, 2,
	2, 70, 600, 3, 2, 2, 2, 72, 607, 3, 2, 2, 2, 74, 610, 3, 2, 2, 2, 76, 622,
	3, 2, 2, 2, 78, 630, 3, 2, 2, 2, 80, 643, 3, 2, 2, 2, 82, 647, 3, 2, 2,
	2, 84, 657, 3, 2, 2, 2, 86, 668, 3, 2, 2, 2, 88, 670, 3, 2, 2, 2, 90, 680,
	3, 2, 2, 2, 92, 682, 3, 2, 2, 2, 94, 693, 3, 2, 2, 2, 96, 695, 3, 2, 2,
	2, 98, 703, 3, 2, 2, 2, 100, 706, 3, 2, 2, 2, 102, 708, 3, 2, 2, 2, 104,
	722, 3, 2, 2, 2, 106, 724, 3, 2, 2, 2, 108, 739, 3, 2, 2, 2, 110, 745,
	3, 2, 2, 2, 112, 757, 3, 2, 2, 2, 114, 771, 3, 2, 2, 2, 116, 778, 3, 2,
	2, 2, 118, 790, 3, 2, 2, 2, 120, 792, 3, 2, 2, 2, 122, 803, 3, 2, 2, 2,
	124, 808, 3, 2, 2, 2, 126, 819, 3, 2, 2, 2, 128, 837, 3, 2, 2, 2, 130,
	839, 3, 2, 2, 2, 132, 844, 3, 2, 2, 2, 134, 846, 3, 2, 2, 2, 136, 854,
	3, 2, 2, 2, 138, 867, 3, 2, 2, 2, 140, 872, 3, 2, 2, 2, 142, 891, 3, 2,
	2, 2, 144, 916, 3, 2, 2, 2, 146, 918, 3, 2, 2, 2, 148, 932, 3, 2, 2, 2,
	150, 938, 3, 2, 2, 2, 152, 947, 3, 2, 2, 2, 154, 956, 3, 2, 2, 2, 156,
	960, 3, 2, 2, 2, 158, 967, 3, 2, 2, 2, 160, 970, 3, 2, 2, 2, 162, 972,
	3, 2, 2, 2, 164, 974, 3, 2, 2, 2, 166, 980, 3, 2, 2, 2, 168, 986, 3, 2,
	2, 2, 170, 990, 3, 2, 2, 2, 172, 1003, 3, 2, 2, 2, 174, 1023, 3, 2, 2,
	2, 176, 1043, 3, 2, 2, 2, 178, 1045, 3, 2, 2, 2, 180, 1047, 3, 2, 2, 2,
	182, 1053, 3, 2, 2, 2, 184, 1055, 3, 2, 2, 2, 186, 1063, 3, 2, 2, 2, 188,
	1070, 3, 2, 2, 2, 190, 1074, 3, 2, 2, 2, 192, 1082, 3, 2, 2, 2, 194, 1095,
	3, 2, 2, 2, 196, 1103, 3, 2, 2, 2, 198, 1108, 3, 2, 2, 2, 200, 1110, 3,
	2, 2, 2, 202, 1120, 3, 2, 2, 2, 204, 1122, 3, 2, 2, 2, 206, 1130, 3, 2,
	2, 2, 208, 1135, 3, 2, 2, 2, 210, 1137, 3, 2, 2, 2, 212, 1139, 3, 2, 2,
	2, 214, 1142, 3, 2, 2, 2, 216, 1147, 3, 2, 2, 2, 218, 1162, 3, 2, 2, 2,
	220, 1164, 3, 2, 2, 2, 222, 1176, 3, 2, 2, 2, 224, 1196, 3, 2, 2, 2, 226,
	1198, 3, 2, 2, 2, 228, 1200, 3, 2, 2, 2, 230, 1208, 3, 2, 2, 2, 232, 1212,
	3, 2, 2, 2, 234, 1214, 3, 2, 2, 2, 236, 1231, 3, 2, 2, 2, 238, 1233, 3,
	2, 2, 2, 240, 1235, 3, 2, 2, 2, 242, 1239, 3, 2, 2, 2, 244, 1251, 3, 2,
	2, 2, 246, 1253, 3, 2, 2, 2, 248, 1260, 3, 2, 2, 2, 250, 1263, 3, 2, 2,
	2, 252, 1268, 3, 2, 2, 2, 254, 1272, 3, 2, 2, 2, 256, 1275, 3, 2, 2, 2,
	258, 1282, 3, 2, 2, 2, 260, 1285, 3, 2, 2, 2, 262, 1292, 3, 2, 2, 2, 264,
	1294, 3, 2, 2, 2, 266, 1303, 3, 2, 2, 2, 268, 1311, 3, 2, 2, 2, 270, 1319,
	3, 2, 2, 2, 272, 1327, 3, 2, 2, 2, 274, 1335, 3, 2, 2, 2, 276, 1343, 3,
	2, 2, 2, 278, 1351, 3, 2, 2, 2, 280, 1359, 3, 2, 2, 2, 282, 1368, 3, 2,
	2, 2, 284, 1371, 3, 2, 2, 2, 286, 1373, 3, 2, 2, 2, 288, 1381, 3, 2, 2,
	2, 290, 1388, 3, 2, 2, 2, 292, 1394, 3, 2, 2, 2, 294, 1398, 3, 2, 2, 2,
	296, 1413, 3, 2, 2, 2, 298, 1424, 3, 2, 2, 2, 300, 1426, 3, 2, 2, 2, 302,
	1435, 3, 2, 2, 2, 304, 1439, 3, 2, 2, 2, 306, 1444, 3, 2, 2, 2, 308, 1449,
	3, 2, 2, 2, 310, 1451, 3, 2, 2, 2, 312, 1462, 3, 2, 2, 2, 314, 1468, 3,
	2, 2, 2, 316, 1476, 3, 2, 2, 2, 318, 1481, 3, 2, 2, 2, 320, 1483, 3, 2,
	2, 2, 322, 1485, 3, 2, 2, 2, 324, 1487, 3, 2, 2, 2, 326, 1490, 3, 2, 2,
	2, 328, 1515, 3, 2, 2, 2, 330, 1519, 3, 2, 2, 2, 332, 1523, 3, 2, 2, 2,
	334, 1531, 3, 2, 2, 2, 336, 1533, 3, 2, 2, 2, 338, 1552, 3, 2, 2, 2, 340,
	1583, 3, 2, 2, 2, 342, 1610, 3, 2, 2, 2, 344, 1617, 3, 2, 2, 2, 346, 1620,
	3, 2, 2, 2, 348, 1652, 3, 2, 2, 2, 350, 1657, 3, 2, 2, 2, 352, 353, 7,
	39, 2, 2, 353, 358, 7, 64, 2, 2, 354, 355, 7, 37, 2, 2, 355, 357, 7, 64,
	2, 2, 356, 354, 3, 2, 2, 2, 357, 360, 3, 2, 2, 2, 358, 356, 3, 2, 2, 2,
	358, 359, 3, 2, 2, 2, 359, 3, 3, 2, 2, 2, 360, 358, 3, 2, 2, 2, 361, 362,
	7, 52, 2, 2, 362, 365, 7, 59, 2, 2, 363, 364, 7, 44, 2, 2, 364, 366, 7,
	59, 2, 2, 365, 363, 3, 2, 2, 2, 365, 366, 3, 2, 2, 2, 366, 367, 3, 2, 2,
	2, 367, 368, 7, 53, 2, 2, 368, 5, 3, 2, 2, 2, 369, 370, 9, 2, 2, 2, 370,
	7, 3, 2, 2, 2, 371, 374, 5, 68, 35, 2, 372, 373, 9, 3, 2, 2, 373, 375,
	5, 6, 4, 2, 374, 372, 3, 2, 2, 2, 375, 376, 3, 2, 2, 2, 376, 374, 3, 2,
	2, 2, 376, 377, 3, 2, 2, 2, 377, 9, 3, 2, 2, 2, 378, 379, 7, 56, 2, 2,
	379, 380, 7, 71, 2, 2, 380, 11, 3, 2, 2, 2, 381, 382, 7, 60, 2, 2, 382,
	13, 3, 2, 2, 2, 383, 384, 7, 48, 2, 2, 384, 389, 5, 12, 7, 2, 385, 386,
	7, 40, 2, 2, 386, 388, 5, 12, 7, 2, 387, 385, 3, 2, 2, 2, 388, 391, 3,
	2, 2, 2, 389, 387, 3, 2, 2, 2, 389, 390, 3, 2, 2, 2, 390, 392, 3, 2, 2,
	2, 391, 389, 3, 2, 2, 2, 392, 393, 7, 49, 2, 2, 393, 15, 3, 2, 2, 2, 394,
	395, 7, 48, 2, 2, 395, 400, 5, 14, 8, 2, 396, 397, 7, 40, 2, 2, 397, 399,
	5, 14, 8, 2, 398, 396, 3, 2, 2, 2, 399, 402, 3, 2, 2, 2, 400, 398, 3, 2,
	2, 2, 400, 401, 3, 2, 2, 2, 401, 403, 3, 2, 2, 2, 402, 400, 3, 2, 2, 2,
	403, 404, 7, 49, 2, 2, 404, 17, 3, 2, 2, 2, 405, 406, 7, 64, 2, 2, 406,
	410, 7, 41, 2, 2, 407, 411, 5, 12, 7, 2, 408, 411, 5, 14, 8, 2, 409, 411,
	5, 16, 9, 2, 410, 407, 3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 410, 409, 3, 2,
	2, 2, 411, 19, 3, 2, 2, 2, 412, 415, 5, 18, 10, 2, 413, 415, 5, 2, 2, 2,
	414, 412, 3, 2, 2, 2, 414, 413, 3, 2, 2, 2, 415, 21, 3, 2, 2, 2, 416, 417,
	7, 48, 2, 2, 417, 422, 5, 20, 11, 2, 418, 419, 7, 40, 2, 2, 419, 421, 5,
	20, 11, 2, 420, 418, 3, 2, 2, 2, 421, 424, 3, 2, 2, 2, 422, 420, 3, 2,
	2, 2, 422, 423, 3, 2, 2, 2, 423, 425, 3, 2, 2, 2, 424, 422, 3, 2, 2, 2,
	425, 426, 7, 49, 2, 2, 426, 23, 3, 2, 2, 2, 427, 428, 5, 6, 4, 2, 428,
	25, 3, 2, 2, 2, 429, 433, 5, 24, 13, 2, 430, 433, 5, 8, 5, 2, 431, 433,
	7, 5, 2, 2, 432, 429, 3, 2, 2, 2, 432, 430, 3, 2, 2, 2, 432, 431, 3, 2,
	2, 2, 433, 27, 3, 2, 2, 2, 434, 437, 7, 27, 2, 2, 435, 437, 7, 123, 2,
	2, 436, 434, 3, 2, 2, 2, 436, 435, 3, 2, 2, 2, 437, 29, 3, 2, 2, 2, 438,
	439, 5, 28, 15, 2, 439, 441, 5, 26, 14, 2, 440, 442, 5, 4, 3, 2, 441, 440,
	3, 2, 2, 2, 441, 442, 3, 2, 2, 2, 442, 31, 3, 2, 2, 2, 443, 446, 7, 26,
	2, 2, 444, 446, 7, 122, 2, 2, 445, 443, 3, 2, 2, 2, 445, 444, 3, 2, 2,
	2, 446, 33, 3, 2, 2, 2, 447, 448, 5, 32, 17, 2, 448, 450, 5, 26, 14, 2,
	449, 451, 5, 4, 3, 2, 450, 449, 3, 2, 2, 2, 450, 451, 3, 2, 2, 2, 451,
	35, 3, 2, 2, 2, 452, 455, 5, 30, 16, 2, 453, 455, 5, 34, 18, 2, 454, 452,
	3, 2, 2, 2, 454, 453, 3, 2, 2, 2, 455, 37, 3, 2, 2, 2, 456, 457, 7, 43,
	2, 2, 457, 459, 7, 3, 2, 2, 458, 460, 5, 10, 6, 2, 459, 458, 3, 2, 2, 2,
	460, 461, 3, 2, 2, 2, 461, 459, 3, 2, 2, 2, 461, 462, 3, 2, 2, 2, 462,
	463, 3, 2, 2, 2, 463, 464, 7, 4, 2, 2, 464, 39, 3, 2, 2, 2, 465, 469, 7,
	60, 2, 2, 466, 469, 5, 14, 8, 2, 467, 469, 5, 38, 20, 2, 468, 465, 3, 2,
	2, 2, 468, 466, 3, 2, 2, 2, 468, 467, 3, 2, 2, 2, 469, 41, 3, 2, 2, 2,
	470, 471, 7, 46, 2, 2, 471, 472, 7, 73, 2, 2, 472, 473, 7, 41, 2, 2, 473,
	474, 5, 40, 21, 2, 474, 43, 3, 2, 2, 2, 475, 477, 7, 3, 2, 2, 476, 478,
	5, 42, 22, 2, 477, 476, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 477, 3,
	2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 481, 3, 2, 2, 2, 481, 482, 7, 4, 2,
	2, 482, 45, 3, 2, 2, 2, 483, 490, 5, 36, 19, 2, 484, 487, 5, 26, 14, 2,
	485, 488, 5, 48, 25, 2, 486, 488, 5, 4, 3, 2, 487, 485, 3, 2, 2, 2, 487,
	486, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 490, 3, 2, 2, 2, 489, 483,
	3, 2, 2, 2, 489, 484, 3, 2, 2, 2, 490, 492, 3, 2, 2, 2, 491, 493, 7, 45,
	2, 2, 492, 491, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 495, 3, 2, 2, 2,
	494, 496, 5, 22, 12, 2, 495, 494, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496,
	499, 3, 2, 2, 2, 497, 498, 7, 43, 2, 2, 498, 500, 5, 44, 23, 2, 499, 497,
	3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 47, 3, 2, 2, 2, 501, 502, 7, 52,
	2, 2, 502, 503, 7, 59, 2, 2, 503, 505, 7, 25, 2, 2, 504, 506, 7, 59, 2,
	2, 505, 504, 3, 2, 2, 2, 505, 506, 3, 2, 2, 2, 506, 507, 3, 2, 2, 2, 507,
	508, 7, 53, 2, 2, 508, 49, 3, 2, 2, 2, 509, 511, 7, 3, 2, 2, 510, 512,
	5, 52, 27, 2, 511, 510, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 511, 3,
	2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515, 516, 7, 4, 2,
	2, 516, 51, 3, 2, 2, 2, 517, 529, 5, 6, 4, 2, 518, 520, 5, 48, 25, 2, 519,
	518, 3, 2, 2, 2, 519, 520, 3, 2, 2, 2, 520, 521, 3, 2, 2, 2, 521, 524,
	7, 33, 2, 2, 522, 525, 5, 46, 24, 2, 523, 525, 5, 50, 26, 2, 524, 522,
	3, 2, 2, 2, 524, 523, 3, 2, 2, 2, 525, 527, 3, 2, 2, 2, 526, 528, 7, 60,
	2, 2, 527, 526, 3, 2, 2, 2, 527, 528, 3, 2, 2, 2, 528, 530, 3, 2, 2, 2,
	529, 519, 3, 2, 2, 2, 529, 530, 3, 2, 2, 2, 530, 53, 3, 2, 2, 2, 531, 532,
	5, 60, 31, 2, 532, 55, 3, 2, 2, 2, 533, 539, 7, 3, 2, 2, 534, 540, 7, 62,
	2, 2, 535, 540, 5, 52, 27, 2, 536, 540, 5, 42, 22, 2, 537, 540, 5, 54,
	28, 2, 538, 540, 7, 24, 2, 2, 539, 534, 3, 2, 2, 2, 539, 535, 3, 2, 2,
	2, 539, 536, 3, 2, 2, 2, 539, 537, 3, 2, 2, 2, 539, 538, 3, 2, 2, 2, 540,
	541, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542, 543,
	3, 2, 2, 2, 543, 544, 7, 4, 2, 2, 544, 57, 3, 2, 2, 2, 545, 547, 5, 22,
	12, 2, 546, 545, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547, 548, 3, 2, 2, 2,
	548, 551, 7, 43, 2, 2, 549, 552, 7, 24, 2, 2, 550, 552, 5, 56, 29, 2, 551,
	549, 3, 2, 2, 2, 551, 550, 3, 2, 2, 2, 552, 59, 3, 2, 2, 2, 553, 555, 7,
	62, 2, 2, 554, 553, 3, 2, 2, 2, 555, 558, 3, 2, 2, 2, 556, 554, 3, 2, 2,
	2, 556, 557, 3, 2, 2, 2, 557, 559, 3, 2, 2, 2, 558, 556, 3, 2, 2, 2, 559,
	560, 9, 4, 2, 2, 560, 561, 5, 6, 4, 2, 561, 562, 5, 58, 30, 2, 562, 61,
	3, 2, 2, 2, 563, 565, 7, 62, 2, 2, 564, 563, 3, 2, 2, 2, 565, 568, 3, 2,
	2, 2, 566, 564, 3, 2, 2, 2, 566, 567, 3, 2, 2, 2, 567, 569, 3, 2, 2, 2,
	568, 566, 3, 2, 2, 2, 569, 570, 7, 11, 2, 2, 570, 572, 5, 6, 4, 2, 571,
	573, 5, 22, 12, 2, 572, 571, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 574,
	3, 2, 2, 2, 574, 586, 7, 43, 2, 2, 575, 587, 7, 24, 2, 2, 576, 581, 7,
	3, 2, 2, 577, 582, 7, 62, 2, 2, 578, 582, 5, 24, 13, 2, 579, 582, 5, 42,
	22, 2, 580, 582, 7, 24, 2, 2, 581, 577, 3, 2, 2, 2, 581, 578, 3, 2, 2,
	2, 581, 579, 3, 2, 2, 2, 581, 580, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2, 583,
	581, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 585, 3, 2, 2, 2, 585, 587,
	7, 4, 2, 2, 586, 575, 3, 2, 2, 2, 586, 576, 3, 2, 2, 2, 587, 63, 3, 2,
	2, 2, 588, 589, 5, 6, 4, 2, 589, 65, 3, 2, 2, 2, 590, 591, 7, 32, 2, 2,
	591, 592, 5, 64, 33, 2, 592, 67, 3, 2, 2, 2, 593, 597, 5, 64, 33, 2, 594,
	596, 5, 66, 34, 2, 595, 594, 3, 2, 2, 2, 596, 599, 3, 2, 2, 2, 597, 595,
	3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598, 69, 3, 2, 2, 2, 599, 597, 3, 2,
	2, 2, 600, 602, 5, 68, 35, 2, 601, 603, 7, 60, 2, 2, 602, 601, 3, 2, 2,
	2, 602, 603, 3, 2, 2, 2, 603, 605, 3, 2, 2, 2, 604, 606, 5, 22, 12, 2,
	605, 604, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606, 71, 3, 2, 2, 2, 607, 608,
	7, 64, 2, 2, 608, 609, 7, 43, 2, 2, 609, 73, 3, 2, 2, 2, 610, 611, 7, 43,
	2, 2, 611, 616, 7, 3, 2, 2, 612, 614, 7, 64, 2, 2, 613, 615, 5, 22, 12,
	2, 614, 613, 3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 615, 617, 3, 2, 2, 2, 616,
	612, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2, 618, 619,
	3, 2, 2, 2, 619, 620, 3, 2, 2, 2, 620, 621, 7, 4, 2, 2, 621, 75, 3, 2,
	2, 2, 622, 623, 9, 5, 2, 2, 623, 625, 7, 64, 2, 2, 624, 626, 5, 74, 38,
	2, 625, 624, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 77, 3, 2, 2, 2, 627,
	629, 7, 62, 2, 2, 628, 627, 3, 2, 2, 2, 629, 632, 3, 2, 2, 2, 630, 628,
	3, 2, 2, 2, 630, 631, 3, 2, 2, 2, 631, 633, 3, 2, 2, 2, 632, 630, 3, 2,
	2, 2, 633, 634, 7, 7, 2, 2, 634, 635, 5, 72, 37, 2, 635, 637, 7, 3, 2,
	2, 636, 638, 5, 76, 39, 2, 637, 636, 3, 2, 2, 2, 638, 639, 3, 2, 2, 2,
	639, 637, 3, 2, 2, 2, 639, 640, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641,
	642, 7, 4, 2, 2, 642, 79, 3, 2, 2, 2, 643, 644, 7, 50, 2, 2, 644, 645,
	7, 64, 2, 2, 645, 646, 7, 51, 2, 2, 646, 81, 3, 2, 2, 2, 647, 648, 7, 64,
	2, 2, 648, 652, 7, 41, 2, 2, 649, 653, 7, 5, 2, 2, 650, 653, 5, 6, 4, 2,
	651, 653, 5, 80, 41, 2, 652, 649, 3, 2, 2, 2, 652, 650, 3, 2, 2, 2, 652,
	651, 3, 2, 2, 2, 653, 655, 3, 2, 2, 2, 654, 656, 7, 45, 2, 2, 655, 654,
	3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 83, 3, 2, 2, 2, 657, 658, 7, 45,
	2, 2, 658, 663, 5, 82, 42, 2, 659, 660, 7, 47, 2, 2, 660, 662, 5, 82, 42,
	2, 661, 659, 3, 2, 2, 2, 662, 665, 3, 2, 2, 2, 663, 661, 3, 2, 2, 2, 663,
	664, 3, 2, 2, 2, 664, 85, 3, 2, 2, 2, 665, 663, 3, 2, 2, 2, 666, 669, 5,
	6, 4, 2, 667, 669, 7, 59, 2, 2, 668, 666, 3, 2, 2, 2, 668, 667, 3, 2, 2,
	2, 669, 87, 3, 2, 2, 2, 670, 671, 7, 50, 2, 2, 671, 672, 5, 86, 44, 2,
	672, 676, 7, 33, 2, 2, 673, 677, 7, 5, 2, 2, 674, 677, 5, 6, 4, 2, 675,
	677, 5, 8, 5, 2, 676, 673, 3, 2, 2, 2, 676, 674, 3, 2, 2, 2, 676, 675,
	3, 2, 2, 2, 677, 678, 3, 2, 2, 2, 678, 679, 7, 51, 2, 2, 679, 89, 3, 2,
	2, 2, 680, 681, 5, 86, 44, 2, 681, 91, 3, 2, 2, 2, 682, 685, 7, 42, 2,
	2, 683, 686, 5, 90, 46, 2, 684, 686, 5, 88, 45, 2, 685, 683, 3, 2, 2, 2,
	685, 684, 3, 2, 2, 2, 686, 93, 3, 2, 2, 2, 687, 694, 7, 42, 2, 2, 688,
	690, 5, 92, 47, 2, 689, 688, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 689,
	3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 694, 3, 2, 2, 2, 693, 687, 3, 2,
	2, 2, 693, 689, 3, 2, 2, 2, 694, 95, 3, 2, 2, 2, 695, 700, 5, 6, 4, 2,
	696, 697, 7, 42, 2, 2, 697, 699, 5, 6, 4, 2, 698, 696, 3, 2, 2, 2, 699,
	702, 3, 2, 2, 2, 700, 698, 3, 2, 2, 2, 700, 701, 3, 2, 2, 2, 701, 97, 3,
	2, 2, 2, 702, 700, 3, 2, 2, 2, 703, 704, 7, 15, 2, 2, 704, 705, 7, 71,
	2, 2, 705, 99, 3, 2, 2, 2, 706, 707, 5, 68, 35, 2, 707, 101, 3, 2, 2, 2,
	708, 709, 5, 6, 4, 2, 709, 103, 3, 2, 2, 2, 710, 713, 7, 60, 2, 2, 711,
	713, 5, 6, 4, 2, 712, 710, 3, 2, 2, 2, 712, 711, 3, 2, 2, 2, 713, 714,
	3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 723, 3, 2,
	2, 2, 716, 717, 5, 6, 4, 2, 717, 720, 7, 33, 2, 2, 718, 721, 5, 6, 4, 2,
	719, 721, 7, 5, 2, 2, 720, 718, 3, 2, 2, 2, 720, 719, 3, 2, 2, 2, 721,
	723, 3, 2, 2, 2, 722, 712, 3, 2, 2, 2, 722, 716, 3, 2, 2, 2, 723, 105,
	3, 2, 2, 2, 724, 725, 7, 52, 2, 2, 725, 730, 5, 104, 53, 2, 726, 727, 7,
	40, 2, 2, 727, 729, 5, 104, 53, 2, 728, 726, 3, 2, 2, 2, 729, 732, 3, 2,
	2, 2, 730, 728, 3, 2, 2, 2, 730, 731, 3, 2, 2, 2, 731, 733, 3, 2, 2, 2,
	732, 730, 3, 2, 2, 2, 733, 734, 7, 53, 2, 2, 734, 107, 3, 2, 2, 2, 735,
	740, 7, 31, 2, 2, 736, 737, 5, 100, 51, 2, 737, 738, 7, 34, 2, 2, 738,
	740, 3, 2, 2, 2, 739, 735, 3, 2, 2, 2, 739, 736, 3, 2, 2, 2, 740, 741,
	3, 2, 2, 2, 741, 743, 5, 102, 52, 2, 742, 744, 5, 106, 54, 2, 743, 742,
	3, 2, 2, 2, 743, 744, 3, 2, 2, 2, 744, 109, 3, 2, 2, 2, 745, 746, 7, 16,
	2, 2, 746, 747, 7, 67, 2, 2, 747, 748, 7, 43, 2, 2, 748, 752, 7, 3, 2,
	2, 749, 751, 5, 138, 70, 2, 750, 749, 3, 2, 2, 2, 751, 754, 3, 2, 2, 2,
	752, 750, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2, 753, 755, 3, 2, 2, 2, 754,
	752, 3, 2, 2, 2, 755, 756, 7, 4, 2, 2, 756, 111, 3, 2, 2, 2, 757, 759,
	7, 20, 2, 2, 758, 760, 7, 67, 2, 2, 759, 758, 3, 2, 2, 2, 759, 760, 3,
	2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 762, 7, 43, 2, 2, 762, 766, 7, 3, 2,
	2, 763, 765, 5, 138, 70, 2, 764, 763, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2,
	766, 764, 3, 2, 2, 2, 766, 767, 3, 2, 2, 2, 767, 769, 3, 2, 2, 2, 768,
	766, 3, 2, 2, 2, 769, 770, 7, 4, 2, 2, 770, 113, 3, 2, 2, 2, 771, 775,
	5, 110, 56, 2, 772, 774, 5, 112, 57, 2, 773, 772, 3, 2, 2, 2, 774, 777,
	3, 2, 2, 2, 775, 773, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 115, 3, 2,
	2, 2, 777, 775, 3, 2, 2, 2, 778, 779, 9, 6, 2, 2, 779, 780, 7, 67, 2, 2,
	780, 781, 7, 43, 2, 2, 781, 785, 7, 3, 2, 2, 782, 784, 5, 138, 70, 2, 783,
	782, 3, 2, 2, 2, 784, 787, 3, 2, 2, 2, 785, 783, 3, 2, 2, 2, 785, 786,
	3, 2, 2, 2, 786, 788, 3, 2, 2, 2, 787, 785, 3, 2, 2, 2, 788, 789, 7, 4,
	2, 2, 789, 117, 3, 2, 2, 2, 790, 791, 7, 62, 2, 2, 791, 119, 3, 2, 2, 2,
	792, 793, 5, 6, 4, 2, 793, 794, 7, 43, 2, 2, 794, 796, 7, 3, 2, 2, 795,
	797, 5, 138, 70, 2, 796, 795, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 796,
	3, 2, 2, 2, 798, 799, 3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 801, 7, 4,
	2, 2, 801, 121, 3, 2, 2, 2, 802, 804, 9, 7, 2, 2, 803, 802, 3, 2, 2, 2,
	804, 805, 3, 2, 2, 2, 805, 803, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806,
	123, 3, 2, 2, 2, 807, 809, 5, 122, 62, 2, 808, 807, 3, 2, 2, 2, 808, 809,
	3, 2, 2, 2, 809, 810, 3, 2, 2, 2, 810, 811, 7, 43, 2, 2, 811, 813, 7, 3,
	2, 2, 812, 814, 5, 138, 70, 2, 813, 812, 3, 2, 2, 2, 814, 815, 3, 2, 2,
	2, 815, 813, 3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2, 817,
	818, 7, 4, 2, 2, 818, 125, 3, 2, 2, 2, 819, 820, 7, 28, 2, 2, 820, 821,
	7, 43, 2, 2, 821, 823, 7, 3, 2, 2, 822, 824, 5, 124, 63, 2, 823, 822, 3,
	2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 823, 3, 2, 2, 2, 825, 826, 3, 2, 2,
	2, 826, 827, 3, 2, 2, 2, 827, 828, 7, 4, 2, 2, 828, 127, 3, 2, 2, 2, 829,
	838, 5, 10, 6, 2, 830, 838, 7, 60, 2, 2, 831, 834, 5, 68, 35, 2, 832, 833,
	7, 35, 2, 2, 833, 835, 5, 6, 4, 2, 834, 832, 3, 2, 2, 2, 834, 835, 3, 2,
	2, 2, 835, 838, 3, 2, 2, 2, 836, 838, 7, 24, 2, 2, 837, 829, 3, 2, 2, 2,
	837, 830, 3, 2, 2, 2, 837, 831, 3, 2, 2, 2, 837, 836, 3, 2, 2, 2, 838,
	129, 3, 2, 2, 2, 839, 840, 7, 29, 2, 2, 840, 841, 5, 68, 35, 2, 841, 131,
	3, 2, 2, 2, 842, 845, 5, 8, 5, 2, 843, 845, 5, 52, 27, 2, 844, 842, 3,
	2, 2, 2, 844, 843, 3, 2, 2, 2, 845, 133, 3, 2, 2, 2, 846, 851, 5, 132,
	67, 2, 847, 848, 7, 40, 2, 2, 848, 850, 5, 132, 67, 2, 849, 847, 3, 2,
	2, 2, 850, 853, 3, 2, 2, 2, 851, 849, 3, 2, 2, 2, 851, 852, 3, 2, 2, 2,
	852, 135, 3, 2, 2, 2, 853, 851, 3, 2, 2, 2, 854, 855, 7, 52, 2, 2, 855,
	856, 5, 134, 68, 2, 856, 857, 7, 53, 2, 2, 857, 137, 3, 2, 2, 2, 858, 868,
	5, 114, 58, 2, 859, 868, 5, 116, 59, 2, 860, 868, 5, 98, 50, 2, 861, 868,
	5, 108, 55, 2, 862, 868, 5, 126, 64, 2, 863, 868, 5, 118, 60, 2, 864, 868,
	5, 120, 61, 2, 865, 868, 5, 128, 65, 2, 866, 868, 5, 42, 22, 2, 867, 858,
	3, 2, 2, 2, 867, 859, 3, 2, 2, 2, 867, 860, 3, 2, 2, 2, 867, 861, 3, 2,
	2, 2, 867, 862, 3, 2, 2, 2, 867, 863, 3, 2, 2, 2, 867, 864, 3, 2, 2, 2,
	867, 865, 3, 2, 2, 2, 867, 866, 3, 2, 2, 2, 868, 870, 3, 2, 2, 2, 869,
	871, 5, 22, 12, 2, 870, 869, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2, 871, 139,
	3, 2, 2, 2, 872, 874, 7, 6, 2, 2, 873, 875, 5, 136, 69, 2, 874, 873, 3,
	2, 2, 2, 874, 875, 3, 2, 2, 2, 875, 877, 3, 2, 2, 2, 876, 878, 5, 84, 43,
	2, 877, 876, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 880, 3, 2, 2, 2, 879,
	881, 5, 22, 12, 2, 880, 879, 3, 2, 2, 2, 880, 881, 3, 2, 2, 2, 881, 882,
	3, 2, 2, 2, 882, 883, 7, 43, 2, 2, 883, 885, 7, 3, 2, 2, 884, 886, 5, 138,
	70, 2, 885, 884, 3, 2, 2, 2, 886, 887, 3, 2, 2, 2, 887, 885, 3, 2, 2, 2,
	887, 888, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 890, 7, 4, 2, 2, 890,
	141, 3, 2, 2, 2, 891, 892, 7, 24, 2, 2, 892, 143, 3, 2, 2, 2, 893, 917,
	7, 24, 2, 2, 894, 896, 5, 96, 49, 2, 895, 897, 7, 60, 2, 2, 896, 895, 3,
	2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 899, 3, 2, 2, 2, 898, 900, 5, 136,
	69, 2, 899, 898, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 902, 3, 2, 2, 2,
	901, 903, 5, 22, 12, 2, 902, 901, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903,
	904, 3, 2, 2, 2, 904, 914, 7, 43, 2, 2, 905, 915, 5, 142, 72, 2, 906, 908,
	7, 3, 2, 2, 907, 909, 5, 138, 70, 2, 908, 907, 3, 2, 2, 2, 909, 910, 3,
	2, 2, 2, 910, 908, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911, 912, 3, 2, 2,
	2, 912, 913, 7, 4, 2, 2, 913, 915, 3, 2, 2, 2, 914, 905, 3, 2, 2, 2, 914,
	906, 3, 2, 2, 2, 915, 917, 3, 2, 2, 2, 916, 893, 3, 2, 2, 2, 916, 894,
	3, 2, 2, 2, 917, 145, 3, 2, 2, 2, 918, 920, 5, 94, 48, 2, 919, 921, 5,
	22, 12, 2, 920, 919, 3, 2, 2, 2, 920, 921, 3, 2, 2, 2, 921, 922, 3, 2,
	2, 2, 922, 923, 7, 43, 2, 2, 923, 926, 7, 3, 2, 2, 924, 927, 5, 140, 71,
	2, 925, 927, 5, 146, 74, 2, 926, 924, 3, 2, 2, 2, 926, 925, 3, 2, 2, 2,
	927, 928, 3, 2, 2, 2, 928, 926, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929,
	930, 3, 2, 2, 2, 930, 931, 7, 4, 2, 2, 931, 147, 3, 2, 2, 2, 932, 933,
	5, 6, 4, 2, 933, 936, 7, 41, 2, 2, 934, 937, 7, 5, 2, 2, 935, 937, 5, 6,
	4, 2, 936, 934, 3, 2, 2, 2, 936, 935, 3, 2, 2, 2, 937, 149, 3, 2, 2, 2,
	938, 939, 7, 45, 2, 2, 939, 944, 5, 148, 75, 2, 940, 941, 7, 47, 2, 2,
	941, 943, 5, 148, 75, 2, 942, 940, 3, 2, 2, 2, 943, 946, 3, 2, 2, 2, 944,
	942, 3, 2, 2, 2, 944, 945, 3, 2, 2, 2, 945, 151, 3, 2, 2, 2, 946, 944,
	3, 2, 2, 2, 947, 948, 5, 100, 51, 2, 948, 949, 7, 34, 2, 2, 949, 950, 5,
	102, 52, 2, 950, 153, 3, 2, 2, 2, 951, 957, 5, 6, 4, 2, 952, 953, 7, 50,
	2, 2, 953, 954, 5, 6, 4, 2, 954, 955, 7, 51, 2, 2, 955, 957, 3, 2, 2, 2,
	956, 951, 3, 2, 2, 2, 956, 952, 3, 2, 2, 2, 957, 155, 3, 2, 2, 2, 958,
	959, 7, 42, 2, 2, 959, 961, 5, 154, 78, 2, 960, 958, 3, 2, 2, 2, 961, 962,
	3, 2, 2, 2, 962, 960, 3, 2, 2, 2, 962, 963, 3, 2, 2, 2, 963, 965, 3, 2,
	2, 2, 964, 966, 5, 150, 76, 2, 965, 964, 3, 2, 2, 2, 965, 966, 3, 2, 2,
	2, 966, 157, 3, 2, 2, 2, 967, 968, 7, 6, 2, 2, 968, 969, 5, 156, 79, 2,
	969, 159, 3, 2, 2, 2, 970, 971, 5, 68, 35, 2, 971, 161, 3, 2, 2, 2, 972,
	973, 5, 68, 35, 2, 973, 163, 3, 2, 2, 2, 974, 975, 5, 162, 82, 2, 975,
	976, 7, 34, 2, 2, 976, 977, 5, 160, 81, 2, 977, 978, 7, 35, 2, 2, 978,
	979, 5, 6, 4, 2, 979, 165, 3, 2, 2, 2, 980, 981, 5, 6, 4, 2, 981, 167,
	3, 2, 2, 2, 982, 987, 5, 166, 84, 2, 983, 987, 5, 152, 77, 2, 984, 987,
	5, 158, 80, 2, 985, 987, 5, 164, 83, 2, 986, 982, 3, 2, 2, 2, 986, 983,
	3, 2, 2, 2, 986, 984, 3, 2, 2, 2, 986, 985, 3, 2, 2, 2, 987, 988, 3, 2,
	2, 2, 988, 989, 5, 22, 12, 2, 989, 169, 3, 2, 2, 2, 990, 991, 7, 36, 2,
	2, 991, 1001, 7, 43, 2, 2, 992, 1002, 7, 24, 2, 2, 993, 995, 7, 3, 2, 2,
	994, 996, 5, 168, 85, 2, 995, 994, 3, 2, 2, 2, 996, 997, 3, 2, 2, 2, 997,
	995, 3, 2, 2, 2, 997, 998, 3, 2, 2, 2, 998, 999, 3, 2, 2, 2, 999, 1000,
	7, 4, 2, 2, 1000, 1002, 3, 2, 2, 2, 1001, 992, 3, 2, 2, 2, 1001, 993, 3,
	2, 2, 2, 1002, 171, 3, 2, 2, 2, 1003, 1004, 7, 30, 2, 2, 1004, 1006, 5,
	6, 4, 2, 1005, 1007, 5, 136, 69, 2, 1006, 1005, 3, 2, 2, 2, 1006, 1007,
	3, 2, 2, 2, 1007, 1009, 3, 2, 2, 2, 1008, 1010, 5, 22, 12, 2, 1009, 1008,
	3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010, 1011, 3, 2, 2, 2, 1011, 1021,
	7, 43, 2, 2, 1012, 1022, 7, 24, 2, 2, 1013, 1015, 7, 3, 2, 2, 1014, 1016,
	5, 138, 70, 2, 1015, 1014, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1015,
	3, 2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 1019, 3, 2, 2, 2, 1019, 1020,
	7, 4, 2, 2, 1020, 1022, 3, 2, 2, 2, 1021, 1012, 3, 2, 2, 2, 1021, 1013,
	3, 2, 2, 2, 1022, 173, 3, 2, 2, 2, 1023, 1024, 5, 68, 35, 2, 1024, 1025,
	7, 35, 2, 2, 1025, 1027, 5, 6, 4, 2, 1026, 1028, 5, 22, 12, 2, 1027, 1026,
	3, 2, 2, 2, 1027, 1028, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 1039,
	7, 43, 2, 2, 1030, 1040, 7, 24, 2, 2, 1031, 1033, 7, 3, 2, 2, 1032, 1034,
	5, 138, 70, 2, 1033, 1032, 3, 2, 2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 1033,
	3, 2, 2, 2, 1035, 1036, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037, 1038,
	7, 4, 2, 2, 1038, 1040, 3, 2, 2, 2, 1039, 1030, 3, 2, 2, 2, 1039, 1031,
	3, 2, 2, 2, 1040, 175, 3, 2, 2, 2, 1041, 1044, 5, 36, 19, 2, 1042, 1044,
	5, 26, 14, 2, 1043, 1041, 3, 2, 2, 2, 1043, 1042, 3, 2, 2, 2, 1044, 177,
	3, 2, 2, 2, 1045, 1046, 9, 8, 2, 2, 1046, 179, 3, 2, 2, 2, 1047, 1049,
	9, 9, 2, 2, 1048, 1050, 7, 89, 2, 2, 1049, 1048, 3, 2, 2, 2, 1049, 1050,
	3, 2, 2, 2, 1050, 1051, 3, 2, 2, 2, 1051, 1052, 7, 141, 2, 2, 1052, 181,
	3, 2, 2, 2, 1053, 1054, 5, 298, 150, 2, 1054, 183, 3, 2, 2, 2, 1055, 1060,
	5, 182, 92, 2, 1056, 1057, 7, 95, 2, 2, 1057, 1059, 5, 182, 92, 2, 1058,
	1056, 3, 2, 2, 2, 1059, 1062, 3, 2, 2, 2, 1060, 1058, 3, 2, 2, 2, 1060,
	1061, 3, 2, 2, 2, 1061, 185, 3, 2, 2, 2, 1062, 1060, 3, 2, 2, 2, 1063,
	1064, 9, 10, 2, 2, 1064, 1066, 7, 93, 2, 2, 1065, 1067, 5, 184, 93, 2,
	1066, 1065, 3, 2, 2, 2, 1066, 1067, 3, 2, 2, 2, 1067, 1068, 3, 2, 2, 2,
	1068, 1069, 7, 94, 2, 2, 1069, 187, 3, 2, 2, 2, 1070, 1072, 5, 298, 150,
	2, 1071, 1073, 9, 11, 2, 2, 1072, 1071, 3, 2, 2, 2, 1072, 1073, 3, 2, 2,
	2, 1073, 189, 3, 2, 2, 2, 1074, 1079, 5, 188, 95, 2, 1075, 1076, 7, 95,
	2, 2, 1076, 1078, 5, 188, 95, 2, 1077, 1075, 3, 2, 2, 2, 1078, 1081, 3,
	2, 2, 2, 1079, 1077, 3, 2, 2, 2, 1079, 1080, 3, 2, 2, 2, 1080, 191, 3,
	2, 2, 2, 1081, 1079, 3, 2, 2, 2, 1082, 1087, 7, 126, 2, 2, 1083, 1084,
	7, 83, 2, 2, 1084, 1085, 5, 176, 89, 2, 1085, 1086, 7, 84, 2, 2, 1086,
	1088, 3, 2, 2, 2, 1087, 1083, 3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1088,
	1089, 3, 2, 2, 2, 1089, 1090, 7, 93, 2, 2, 1090, 1091, 5, 190, 96, 2, 1091,
	1092, 7, 112, 2, 2, 1092, 1093, 7, 141, 2, 2, 1093, 1094, 7, 94, 2, 2,
	1094, 193, 3, 2, 2, 2, 1095, 1096, 7, 127, 2, 2, 1096, 1098, 7, 93, 2,
	2, 1097, 1099, 5, 196, 99, 2, 1098, 1097, 3, 2, 2, 2, 1098, 1099, 3, 2,
	2, 2, 1099, 1100, 3, 2, 2, 2, 1100, 1101, 5, 184, 93, 2, 1101, 1102, 7,
	94, 2, 2, 1102, 195, 3, 2, 2, 2, 1103, 1104, 7, 141, 2, 2, 1104, 1105,
	7, 92, 2, 2, 1105, 197, 3, 2, 2, 2, 1106, 1109, 7, 120, 2, 2, 1107, 1109,
	5, 298, 150, 2, 1108, 1106, 3, 2, 2, 2, 1108, 1107, 3, 2, 2, 2, 1109, 199,
	3, 2, 2, 2, 1110, 1111, 7, 134, 2, 2, 1111, 1112, 5, 198, 100, 2, 1112,
	1113, 7, 108, 2, 2, 1113, 1115, 7, 93, 2, 2, 1114, 1116, 5, 196, 99, 2,
	1115, 1114, 3, 2, 2, 2, 1115, 1116, 3, 2, 2, 2, 1116, 1117, 3, 2, 2, 2,
	1117, 1118, 5, 190, 96, 2, 1118, 1119, 7, 94, 2, 2, 1119, 201, 3, 2, 2,
	2, 1120, 1121, 9, 12, 2, 2, 1121, 203, 3, 2, 2, 2, 1122, 1123, 5, 202,
	102, 2, 1123, 1125, 7, 93, 2, 2, 1124, 1126, 5, 196, 99, 2, 1125, 1124,
	3, 2, 2, 2, 1125, 1126, 3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2, 1127, 1128,
	5, 298, 150, 2, 1128, 1129, 7, 94, 2, 2, 1129, 205, 3, 2, 2, 2, 1130, 1131,
	7, 128, 2, 2, 1131, 1132, 7, 93, 2, 2, 1132, 1133, 5, 298, 150, 2, 1133,
	1134, 7, 94, 2, 2, 1134, 207, 3, 2, 2, 2, 1135, 1136, 7, 129, 2, 2, 1136,
	209, 3, 2, 2, 2, 1137, 1138, 7, 130, 2, 2, 1138, 211, 3, 2, 2, 2, 1139,
	1140, 7, 132, 2, 2, 1140, 213, 3, 2, 2, 2, 1141, 1143, 7, 142, 2, 2, 1142,
	1141, 3, 2, 2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 1144, 3, 2, 2, 2, 1144,
	1145, 7, 141, 2, 2, 1145, 215, 3, 2, 2, 2, 1146, 1148, 7, 101, 2, 2, 1147,
	1146, 3, 2, 2, 2, 1147, 1148, 3, 2, 2, 2, 1148, 1149, 3, 2, 2, 2, 1149,
	1151, 7, 78, 2, 2, 1150, 1152, 9, 13, 2, 2, 1151, 1150, 3, 2, 2, 2, 1151,
	1152, 3, 2, 2, 2, 1152, 1153, 3, 2, 2, 2, 1153, 1156, 5, 214, 108, 2, 1154,
	1155, 7, 113, 2, 2, 1155, 1157, 7, 141, 2, 2, 1156, 1154, 3, 2, 2, 2, 1156,
	1157, 3, 2, 2, 2, 1157, 217, 3, 2, 2, 2, 1158, 1163, 5, 180, 91, 2, 1159,
	1163, 5, 216, 109, 2, 1160, 1163, 5, 240, 121, 2, 1161, 1163, 7, 141, 2,
	2, 1162, 1158, 3, 2, 2, 2, 1162, 1159, 3, 2, 2, 2, 1162, 1160, 3, 2, 2,
	2, 1162, 1161, 3, 2, 2, 2, 1163, 219, 3, 2, 2, 2, 1164, 1165, 7, 81, 2,
	2, 1165, 1170, 7, 141, 2, 2, 1166, 1167, 7, 95, 2, 2, 1167, 1169, 7, 141,
	2, 2, 1168, 1166, 3, 2, 2, 2, 1169, 1172, 3, 2, 2, 2, 1170, 1168, 3, 2,
	2, 2, 1170, 1171, 3, 2, 2, 2, 1171, 1173, 3, 2, 2, 2, 1172, 1170, 3, 2,
	2, 2, 1173, 1174, 7, 82, 2, 2, 1174, 221, 3, 2, 2, 2, 1175, 1177, 7, 103,
	2, 2, 1176, 1175, 3, 2, 2, 2, 1176, 1177, 3, 2, 2, 2, 1177, 1178, 3, 2,
	2, 2, 1178, 1180, 7, 102, 2, 2, 1179, 1181, 5, 220, 111, 2, 1180, 1179,
	3, 2, 2, 2, 1180, 1181, 3, 2, 2, 2, 1181, 1182, 3, 2, 2, 2, 1182, 1183,
	7, 84, 2, 2, 1183, 1184, 5, 218, 110, 2, 1184, 223, 3, 2, 2, 2, 1185, 1197,
	5, 180, 91, 2, 1186, 1197, 5, 192, 97, 2, 1187, 1197, 5, 194, 98, 2, 1188,
	1197, 5, 204, 103, 2, 1189, 1197, 5, 206, 104, 2, 1190, 1197, 5, 212, 107,
	2, 1191, 1197, 5, 208, 105, 2, 1192, 1197, 5, 210, 106, 2, 1193, 1197,
	5, 200, 101, 2, 1194, 1197, 5, 216, 109, 2, 1195, 1197, 5, 222, 112, 2,
	1196, 1185, 3, 2, 2, 2, 1196, 1186, 3, 2, 2, 2, 1196, 1187, 3, 2, 2, 2,
	1196, 1188, 3, 2, 2, 2, 1196, 1189, 3, 2, 2, 2, 1196, 1190, 3, 2, 2, 2,
	1196, 1191, 3, 2, 2, 2, 1196, 1192, 3, 2, 2, 2, 1196, 1193, 3, 2, 2, 2,
	1196, 1194, 3, 2, 2, 2, 1196, 1195, 3, 2, 2, 2, 1197, 225, 3, 2, 2, 2,
	1198, 1199, 5, 298, 150, 2, 1199, 227, 3, 2, 2, 2, 1200, 1205, 5, 226,
	114, 2, 1201, 1202, 7, 95, 2, 2, 1202, 1204, 5, 226, 114, 2, 1203, 1201,
	3, 2, 2, 2, 1204, 1207, 3, 2, 2, 2, 1205, 1203, 3, 2, 2, 2, 1205, 1206,
	3, 2, 2, 2, 1206, 229, 3, 2, 2, 2, 1207, 1205, 3, 2, 2, 2, 1208, 1209,
	7, 86, 2, 2, 1209, 1210, 5, 228, 115, 2, 1210, 1211, 7, 87, 2, 2, 1211,
	231, 3, 2, 2, 2, 1212, 1213, 7, 85, 2, 2, 1213, 233, 3, 2, 2, 2, 1214,
	1225, 7, 142, 2, 2, 1215, 1226, 5, 192, 97, 2, 1216, 1226, 5, 194, 98,
	2, 1217, 1226, 5, 204, 103, 2, 1218, 1226, 5, 206, 104, 2, 1219, 1226,
	5, 212, 107, 2, 1220, 1226, 5, 208, 105, 2, 1221, 1226, 5, 210, 106, 2,
	1222, 1226, 5, 200, 101, 2, 1223, 1226, 5, 216, 109, 2, 1224, 1226, 5,
	222, 112, 2, 1225, 1215, 3, 2, 2, 2, 1225, 1216, 3, 2, 2, 2, 1225, 1217,
	3, 2, 2, 2, 1225, 1218, 3, 2, 2, 2, 1225, 1219, 3, 2, 2, 2, 1225, 1220,
	3, 2, 2, 2, 1225, 1221, 3, 2, 2, 2, 1225, 1222, 3, 2, 2, 2, 1225, 1223,
	3, 2, 2, 2, 1225, 1224, 3, 2, 2, 2, 1226, 235, 3, 2, 2, 2, 1227, 1232,
	5, 234, 118, 2, 1228, 1232, 5, 216, 109, 2, 1229, 1232, 5, 222, 112, 2,
	1230, 1232, 5, 180, 91, 2, 1231, 1227, 3, 2, 2, 2, 1231, 1228, 3, 2, 2,
	2, 1231, 1229, 3, 2, 2, 2, 1231, 1230, 3, 2, 2, 2, 1232, 237, 3, 2, 2,
	2, 1233, 1234, 9, 14, 2, 2, 1234, 239, 3, 2, 2, 2, 1235, 1236, 7, 93, 2,
	2, 1236, 1237, 5, 298, 150, 2, 1237, 1238, 7, 94, 2, 2, 1238, 241, 3, 2,
	2, 2, 1239, 1240, 7, 81, 2, 2, 1240, 1241, 5, 228, 115, 2, 1241, 1242,
	7, 82, 2, 2, 1242, 243, 3, 2, 2, 2, 1243, 1252, 5, 186, 94, 2, 1244, 1252,
	5, 230, 116, 2, 1245, 1252, 5, 242, 122, 2, 1246, 1252, 5, 232, 117, 2,
	1247, 1252, 5, 240, 121, 2, 1248, 1252, 5, 178, 90, 2, 1249, 1252, 5, 236,
	119, 2, 1250, 1252, 5, 238, 120, 2, 1251, 1243, 3, 2, 2, 2, 1251, 1244,
	3, 2, 2, 2, 1251, 1245, 3, 2, 2, 2, 1251, 1246, 3, 2, 2, 2, 1251, 1247,
	3, 2, 2, 2, 1251, 1248, 3, 2, 2, 2, 1251, 1249, 3, 2, 2, 2, 1251, 1250,
	3, 2, 2, 2, 1252, 245, 3, 2, 2, 2, 1253, 1257, 5, 244, 123, 2, 1254, 1256,
	5, 224, 113, 2, 1255, 1254, 3, 2, 2, 2, 1256, 1259, 3, 2, 2, 2, 1257, 1255,
	3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 1258, 247, 3, 2, 2, 2, 1259, 1257,
	3, 2, 2, 2, 1260, 1261, 7, 90, 2, 2, 1261, 1262, 5, 252, 127, 2, 1262,
	249, 3, 2, 2, 2, 1263, 1265, 5, 246, 124, 2, 1264, 1266, 5, 248, 125, 2,
	1265, 1264, 3, 2, 2, 2, 1265, 1266, 3, 2, 2, 2, 1266, 251, 3, 2, 2, 2,
	1267, 1269, 9, 15, 2, 2, 1268, 1267, 3, 2, 2, 2, 1268, 1269, 3, 2, 2, 2,
	1269, 1270, 3, 2, 2, 2, 1270, 1271, 5, 250, 126, 2, 1271, 253, 3, 2, 2,
	2, 1272, 1273, 9, 16, 2, 2, 1273, 1274, 5, 252, 127, 2, 1274, 255, 3, 2,
	2, 2, 1275, 1279, 5, 252, 127, 2, 1276, 1278, 5, 254, 128, 2, 1277, 1276,
	3, 2, 2, 2, 1278, 1281, 3, 2, 2, 2, 1279, 1277, 3, 2, 2, 2, 1279, 1280,
	3, 2, 2, 2, 1280, 257, 3, 2, 2, 2, 1281, 1279, 3, 2, 2, 2, 1282, 1283,
	9, 17, 2, 2, 1283, 1284, 5, 256, 129, 2, 1284, 259, 3, 2, 2, 2, 1285, 1289,
	5, 256, 129, 2, 1286, 1288, 5, 258, 130, 2, 1287, 1286, 3, 2, 2, 2, 1288,
	1291, 3, 2, 2, 2, 1289, 1287, 3, 2, 2, 2, 1289, 1290, 3, 2, 2, 2, 1290,
	261, 3, 2, 2, 2, 1291, 1289, 3, 2, 2, 2, 1292, 1293, 9, 18, 2, 2, 1293,
	263, 3, 2, 2, 2, 1294, 1300, 5, 260, 131, 2, 1295, 1296, 5, 262, 132, 2,
	1296, 1297, 5, 260, 131, 2, 1297, 1299, 3, 2, 2, 2, 1298, 1295, 3, 2, 2,
	2, 1299, 1302, 3, 2, 2, 2, 1300, 1298, 3, 2, 2, 2, 1300, 1301, 3, 2, 2,
	2, 1301, 265, 3, 2, 2, 2, 1302, 1300, 3, 2, 2, 2, 1303, 1308, 5, 264, 133,
	2, 1304, 1305, 9, 19, 2, 2, 1305, 1307, 5, 264, 133, 2, 1306, 1304, 3,
	2, 2, 2, 1307, 1310, 3, 2, 2, 2, 1308, 1306, 3, 2, 2, 2, 1308, 1309, 3,
	2, 2, 2, 1309, 267, 3, 2, 2, 2, 1310, 1308, 3, 2, 2, 2, 1311, 1316, 5,
	266, 134, 2, 1312, 1313, 7, 104, 2, 2, 1313, 1315, 5, 266, 134, 2, 1314,
	1312, 3, 2, 2, 2, 1315, 1318, 3, 2, 2, 2, 1316, 1314, 3, 2, 2, 2, 1316,
	1317, 3, 2, 2, 2, 1317, 269, 3, 2, 2, 2, 1318, 1316, 3, 2, 2, 2, 1319,
	1324, 5, 268, 135, 2, 1320, 1321, 7, 110, 2, 2, 1321, 1323, 5, 268, 135,
	2, 1322, 1320, 3, 2, 2, 2, 1323, 1326, 3, 2, 2, 2, 1324, 1322, 3, 2, 2,
	2, 1324, 1325, 3, 2, 2, 2, 1325, 271, 3, 2, 2, 2, 1326, 1324, 3, 2, 2,
	2, 1327, 1332, 5, 270, 136, 2, 1328, 1329, 7, 106, 2, 2, 1329, 1331, 5,
	270, 136, 2, 1330, 1328, 3, 2, 2, 2, 1331, 1334, 3, 2, 2, 2, 1332, 1330,
	3, 2, 2, 2, 1332, 1333, 3, 2, 2, 2, 1333, 273, 3, 2, 2, 2, 1334, 1332,
	3, 2, 2, 2, 1335, 1340, 5, 272, 137, 2, 1336, 1337, 7, 105, 2, 2, 1337,
	1339, 5, 272, 137, 2, 1338, 1336, 3, 2, 2, 2, 1339, 1342, 3, 2, 2, 2, 1340,
	1338, 3, 2, 2, 2, 1340, 1341, 3, 2, 2, 2, 1341, 275, 3, 2, 2, 2, 1342,
	1340, 3, 2, 2, 2, 1343, 1348, 5, 274, 138, 2, 1344, 1345, 7, 121, 2, 2,
	1345, 1347, 5, 274, 138, 2, 1346, 1344, 3, 2, 2, 2, 1347, 1350, 3, 2, 2,
	2, 1348, 1346, 3, 2, 2, 2, 1348, 1349, 3, 2, 2, 2, 1349, 277, 3, 2, 2,
	2, 1350, 1348, 3, 2, 2, 2, 1351, 1356, 5, 276, 139, 2, 1352, 1353, 7, 91,
	2, 2, 1353, 1355, 5, 276, 139, 2, 1354, 1352, 3, 2, 2, 2, 1355, 1358, 3,
	2, 2, 2, 1356, 1354, 3, 2, 2, 2, 1356, 1357, 3, 2, 2, 2, 1357, 279, 3,
	2, 2, 2, 1358, 1356, 3, 2, 2, 2, 1359, 1361, 5, 298, 150, 2, 1360, 1362,
	7, 101, 2, 2, 1361, 1360, 3, 2, 2, 2, 1361, 1362, 3, 2, 2, 2, 1362, 1363,
	3, 2, 2, 2, 1363, 1364, 7, 115, 2, 2, 1364, 1365, 5, 298, 150, 2, 1365,
	1366, 7, 116, 2, 2, 1366, 1367, 5, 298, 150, 2, 1367, 281, 3, 2, 2, 2,
	1368, 1369, 5, 298, 150, 2, 1369, 1370, 8, 142, 1, 2, 1370, 283, 3, 2,
	2, 2, 1371, 1372, 5, 298, 150, 2, 1372, 285, 3, 2, 2, 2, 1373, 1378, 5,
	284, 143, 2, 1374, 1375, 7, 95, 2, 2, 1375, 1377, 5, 284, 143, 2, 1376,
	1374, 3, 2, 2, 2, 1377, 1380, 3, 2, 2, 2, 1378, 1376, 3, 2, 2, 2, 1378,
	1379, 3, 2, 2, 2, 1379, 287, 3, 2, 2, 2, 1380, 1378, 3, 2, 2, 2, 1381,
	1382, 5, 286, 144, 2, 1382, 1383, 7, 77, 2, 2, 1383, 1386, 5, 282, 142,
	2, 1384, 1387, 6, 145, 2, 3, 1385, 1387, 7, 145, 2, 2, 1386, 1384, 3, 2,
	2, 2, 1386, 1385, 3, 2, 2, 2, 1387, 289, 3, 2, 2, 2, 1388, 1389, 7, 116,
	2, 2, 1389, 1392, 5, 298, 150, 2, 1390, 1393, 6, 146, 3, 3, 1391, 1393,
	7, 145, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392, 1391, 3, 2, 2, 2, 1393, 291,
	3, 2, 2, 2, 1394, 1395, 5, 298, 150, 2, 1395, 1396, 7, 79, 2, 2, 1396,
	293, 3, 2, 2, 2, 1397, 1399, 5, 292, 147, 2, 1398, 1397, 3, 2, 2, 2, 1398,
	1399, 3, 2, 2, 2, 1399, 1400, 3, 2, 2, 2, 1400, 1401, 7, 92, 2, 2, 1401,
	1402, 7, 145, 2, 2, 1402, 1404, 7, 3, 2, 2, 1403, 1405, 5, 288, 145, 2,
	1404, 1403, 3, 2, 2, 2, 1405, 1406, 3, 2, 2, 2, 1406, 1404, 3, 2, 2, 2,
	1406, 1407, 3, 2, 2, 2, 1407, 1409, 3, 2, 2, 2, 1408, 1410, 5, 290, 146,
	2, 1409, 1408, 3, 2, 2, 2, 1409, 1410, 3, 2, 2, 2, 1410, 1411, 3, 2, 2,
	2, 1411, 1412, 7, 4, 2, 2, 1412, 295, 3, 2, 2, 2, 1413, 1418, 7, 114, 2,
	2, 1414, 1419, 5, 280, 141, 2, 1415, 1416, 5, 294, 148, 2, 1416, 1417,
	8, 149, 1, 2, 1417, 1419, 3, 2, 2, 2, 1418, 1414, 3, 2, 2, 2, 1418, 1415,
	3, 2, 2, 2, 1419, 297, 3, 2, 2, 2, 1420, 1421, 5, 296, 149, 2, 1421, 1422,
	8, 150, 1, 2, 1422, 1425, 3, 2, 2, 2, 1423, 1425, 5, 278, 140, 2, 1424,
	1420, 3, 2, 2, 2, 1424, 1423, 3, 2, 2, 2, 1425, 299, 3, 2, 2, 2, 1426,
	1433, 7, 96, 2, 2, 1427, 1428, 5, 298, 150, 2, 1428, 1429, 8, 151, 1, 2,
	1429, 1434, 3, 2, 2, 2, 1430, 1431, 5, 326, 164, 2, 1431, 1432, 8, 151,
	1, 2, 1432, 1434, 3, 2, 2, 2, 1433, 1427, 3, 2, 2, 2, 1433, 1430, 3, 2,
	2, 2, 1434, 301, 3, 2, 2, 2, 1435, 1436, 7, 141, 2, 2, 1436, 1437, 5, 300,
	151, 2, 1437, 1438, 8, 152, 1, 2, 1438, 303, 3, 2, 2, 2, 1439, 1440, 7,
	117, 2, 2, 1440, 1441, 7, 141, 2, 2, 1441, 1442, 5, 300, 151, 2, 1442,
	1443, 8, 153, 1, 2, 1443, 305, 3, 2, 2, 2, 1444, 1445, 7, 89, 2, 2, 1445,
	1446, 7, 141, 2, 2, 1446, 1447, 5, 300, 151, 2, 1447, 1448, 8, 154, 1,
	2, 1448, 307, 3, 2, 2, 2, 1449, 1450, 7, 140, 2, 2, 1450, 309, 3, 2, 2,
	2, 1451, 1452, 5, 308, 155, 2, 1452, 311, 3, 2, 2, 2, 1453, 1454, 5, 304,
	153, 2, 1454, 1455, 8, 157, 1, 2, 1455, 1463, 3, 2, 2, 2, 1456, 1457, 5,
	306, 154, 2, 1457, 1458, 8, 157, 1, 2, 1458, 1463, 3, 2, 2, 2, 1459, 1460,
	5, 302, 152, 2, 1460, 1461, 8, 157, 1, 2, 1461, 1463, 3, 2, 2, 2, 1462,
	1453, 3, 2, 2, 2, 1462, 1456, 3, 2, 2, 2, 1462, 1459, 3, 2, 2, 2, 1463,
	1466, 3, 2, 2, 2, 1464, 1467, 6, 157, 4, 3, 1465, 1467, 7, 145, 2, 2, 1466,
	1464, 3, 2, 2, 2, 1466, 1465, 3, 2, 2, 2, 1467, 313, 3, 2, 2, 2, 1468,
	1469, 5, 186, 94, 2, 1469, 1470, 7, 142, 2, 2, 1470, 1471, 7, 111, 2, 2,
	1471, 1472, 7, 145, 2, 2, 1472, 315, 3, 2, 2, 2, 1473, 1477, 5, 310, 156,
	2, 1474, 1477, 5, 312, 157, 2, 1475, 1477, 5, 314, 158, 2, 1476, 1473,
	3, 2, 2, 2, 1476, 1474, 3, 2, 2, 2, 1476, 1475, 3, 2, 2, 2, 1477, 317,
	3, 2, 2, 2, 1478, 1482, 5, 28, 15, 2, 1479, 1482, 5, 32, 17, 2, 1480, 1482,
	5, 176, 89, 2, 1481, 1478, 3, 2, 2, 2, 1481, 1479, 3, 2, 2, 2, 1481, 1480,
	3, 2, 2, 2, 1482, 319, 3, 2, 2, 2, 1483, 1484, 5, 176, 89, 2, 1484, 321,
	3, 2, 2, 2, 1485, 1486, 7, 141, 2, 2, 1486, 323, 3, 2, 2, 2, 1487, 1488,
	5, 298, 150, 2, 1488, 325, 3, 2, 2, 2, 1489, 1491, 5, 324, 163, 2, 1490,
	1489, 3, 2, 2, 2, 1490, 1491, 3, 2, 2, 2, 1491, 1492, 3, 2, 2, 2, 1492,
	1497, 7, 78, 2, 2, 1493, 1494, 7, 83, 2, 2, 1494, 1495, 5, 318, 160, 2,
	1495, 1496, 7, 84, 2, 2, 1496, 1498, 3, 2, 2, 2, 1497, 1493, 3, 2, 2, 2,
	1497, 1498, 3, 2, 2, 2, 1498, 1499, 3, 2, 2, 2, 1499, 1501, 7, 93, 2, 2,
	1500, 1502, 5, 322, 162, 2, 1501, 1500, 3, 2, 2, 2, 1501, 1502, 3, 2, 2,
	2, 1502, 1503, 3, 2, 2, 2, 1503, 1504, 7, 92, 2, 2, 1504, 1505, 7, 145,
	2, 2, 1505, 1507, 7, 3, 2, 2, 1506, 1508, 5, 316, 159, 2, 1507, 1506, 3,
	2, 2, 2, 1508, 1509, 3, 2, 2, 2, 1509, 1507, 3, 2, 2, 2, 1509, 1510, 3,
	2, 2, 2, 1510, 1511, 3, 2, 2, 2, 1511, 1512, 7, 4, 2, 2, 1512, 1513, 7,
	94, 2, 2, 1513, 1514, 7, 145, 2, 2, 1514, 327, 3, 2, 2, 2, 1515, 1516,
	7, 3, 2, 2, 1516, 1517, 5, 326, 164, 2, 1517, 1518, 7, 4, 2, 2, 1518, 329,
	3, 2, 2, 2, 1519, 1520, 5, 6, 4, 2, 1520, 1521, 7, 33, 2, 2, 1521, 1522,
	5, 176, 89, 2, 1522, 331, 3, 2, 2, 2, 1523, 1528, 5, 330, 166, 2, 1524,
	1525, 7, 40, 2, 2, 1525, 1527, 5, 330, 166, 2, 1526, 1524, 3, 2, 2, 2,
	1527, 1530, 3, 2, 2, 2, 1528, 1526, 3, 2, 2, 2, 1528, 1529, 3, 2, 2, 2,
	1529, 333, 3, 2, 2, 2, 1530, 1528, 3, 2, 2, 2, 1531, 1532, 7, 38, 2, 2,
	1532, 335, 3, 2, 2, 2, 1533, 1534, 7, 12, 2, 2, 1534, 1535, 5, 6, 4, 2,
	1535, 1536, 7, 52, 2, 2, 1536, 1537, 5, 332, 167, 2, 1537, 1540, 7, 53,
	2, 2, 1538, 1539, 7, 35, 2, 2, 1539, 1541, 5, 320, 161, 2, 1540, 1538,
	3, 2, 2, 2, 1540, 1541, 3, 2, 2, 2, 1541, 1550, 3, 2, 2, 2, 1542, 1544,
	5, 22, 12, 2, 1543, 1542, 3, 2, 2, 2, 1543, 1544, 3, 2, 2, 2, 1544, 1545,
	3, 2, 2, 2, 1545, 1546, 7, 43, 2, 2, 1546, 1551, 5, 328, 165, 2, 1547,
	1548, 5, 334, 168, 2, 1548, 1549, 8, 169, 1, 2, 1549, 1551, 3, 2, 2, 2,
	1550, 1543, 3, 2, 2, 2, 1550, 1547, 3, 2, 2, 2, 1551, 337, 3, 2, 2, 2,
	1552, 1553, 7, 10, 2, 2, 1553, 1555, 5, 6, 4, 2, 1554, 1556, 5, 22, 12,
	2, 1555, 1554, 3, 2, 2, 2, 1555, 1556, 3, 2, 2, 2, 1556, 1557, 3, 2, 2,
	2, 1557, 1581, 7, 43, 2, 2, 1558, 1560, 5, 42, 22, 2, 1559, 1558, 3, 2,
	2, 2, 1560, 1563, 3, 2, 2, 2, 1561, 1559, 3, 2, 2, 2, 1561, 1562, 3, 2,
	2, 2, 1562, 1566, 3, 2, 2, 2, 1563, 1561, 3, 2, 2, 2, 1564, 1567, 5, 26,
	14, 2, 1565, 1567, 5, 36, 19, 2, 1566, 1564, 3, 2, 2, 2, 1566, 1565, 3,
	2, 2, 2, 1567, 1582, 3, 2, 2, 2, 1568, 1572, 7, 3, 2, 2, 1569, 1571, 5,
	42, 22, 2, 1570, 1569, 3, 2, 2, 2, 1571, 1574, 3, 2, 2, 2, 1572, 1570,
	3, 2, 2, 2, 1572, 1573, 3, 2, 2, 2, 1573, 1577, 3, 2, 2, 2, 1574, 1572,
	3, 2, 2, 2, 1575, 1578, 5, 26, 14, 2, 1576, 1578, 5, 36, 19, 2, 1577, 1575,
	3, 2, 2, 2, 1577, 1576, 3, 2, 2, 2, 1578, 1579, 3, 2, 2, 2, 1579, 1580,
	7, 4, 2, 2, 1580, 1582, 3, 2, 2, 2, 1581, 1561, 3, 2, 2, 2, 1581, 1568,
	3, 2, 2, 2, 1582, 339, 3, 2, 2, 2, 1583, 1599, 7, 3, 2, 2, 1584, 1600,
	5, 338, 170, 2, 1585, 1600, 5, 42, 22, 2, 1586, 1600, 5, 170, 86, 2, 1587,
	1600, 5, 172, 87, 2, 1588, 1600, 5, 78, 40, 2, 1589, 1600, 5, 130, 66,
	2, 1590, 1600, 5, 146, 74, 2, 1591, 1600, 5, 144, 73, 2, 1592, 1600, 5,
	174, 88, 2, 1593, 1600, 7, 62, 2, 2, 1594, 1600, 5, 62, 32, 2, 1595, 1596,
	5, 336, 169, 2, 1596, 1597, 8, 171, 1, 2, 1597, 1600, 3, 2, 2, 2, 1598,
	1600, 5, 60, 31, 2, 1599, 1584, 3, 2, 2, 2, 1599, 1585, 3, 2, 2, 2, 1599,
	1586, 3, 2, 2, 2, 1599, 1587, 3, 2, 2, 2, 1599, 1588, 3, 2, 2, 2, 1599,
	1589, 3, 2, 2, 2, 1599, 1590, 3, 2, 2, 2, 1599, 1591, 3, 2, 2, 2, 1599,
	1592, 3, 2, 2, 2, 1599, 1593, 3, 2, 2, 2, 1599, 1594, 3, 2, 2, 2, 1599,
	1595, 3, 2, 2, 2, 1599, 1598, 3, 2, 2, 2, 1600, 1601, 3, 2, 2, 2, 1601,
	1599, 3, 2, 2, 2, 1601, 1602, 3, 2, 2, 2, 1602, 1605, 3, 2, 2, 2, 1603,
	1606, 6, 171, 5, 3, 1604, 1606, 7, 4, 2, 2, 1605, 1603, 3, 2, 2, 2, 1605,
	1604, 3, 2, 2, 2, 1606, 341, 3, 2, 2, 2, 1607, 1609, 7, 62, 2, 2, 1608,
	1607, 3, 2, 2, 2, 1609, 1612, 3, 2, 2, 2, 1610, 1608, 3, 2, 2, 2, 1610,
	1611, 3, 2, 2, 2, 1611, 1613, 3, 2, 2, 2, 1612, 1610, 3, 2, 2, 2, 1613,
	1614, 5, 70, 36, 2, 1614, 1615, 7, 43, 2, 2, 1615, 1616, 5, 340, 171, 2,
	1616, 343, 3, 2, 2, 2, 1617, 1618, 7, 39, 2, 2, 1618, 1619, 7, 64, 2, 2,
	1619, 345, 3, 2, 2, 2, 1620, 1621, 7, 13, 2, 2, 1621, 1631, 7, 146, 2,
	2, 1622, 1623, 7, 14, 2, 2, 1623, 1628, 7, 64, 2, 2, 1624, 1625, 7, 44,
	2, 2, 1625, 1627, 7, 64, 2, 2, 1626, 1624, 3, 2, 2, 2, 1627, 1630, 3, 2,
	2, 2, 1628, 1626, 3, 2, 2, 2, 1628, 1629, 3, 2, 2, 2, 1629, 1632, 3, 2,
	2, 2, 1630, 1628, 3, 2, 2, 2, 1631, 1622, 3, 2, 2, 2, 1631, 1632, 3, 2,
	2, 2, 1632, 1636, 3, 2, 2, 2, 1633, 1635, 7, 65, 2, 2, 1634, 1633, 3, 2,
	2, 2, 1635, 1638, 3, 2, 2, 2, 1636, 1634, 3, 2, 2, 2, 1636, 1637, 3, 2,
	2, 2, 1637, 1640, 3, 2, 2, 2, 1638, 1636, 3, 2, 2, 2, 1639, 1641, 5, 344,
	173, 2, 1640, 1639, 3, 2, 2, 2, 1640, 1641, 3, 2, 2, 2, 1641, 1649, 3,
	2, 2, 2, 1642, 1644, 7, 62, 2, 2, 1643, 1642, 3, 2, 2, 2, 1644, 1647, 3,
	2, 2, 2, 1645, 1643, 3, 2, 2, 2, 1645, 1646, 3, 2, 2, 2, 1646, 1650, 3,
	2, 2, 2, 1647, 1645, 3, 2, 2, 2, 1648, 1650, 7, 61, 2, 2, 1649, 1645, 3,
	2, 2, 2, 1649, 1648, 3, 2, 2, 2, 1650, 347, 3, 2, 2, 2, 1651, 1653, 5,
	346, 174, 2, 1652, 1651, 3, 2, 2, 2, 1653, 1654, 3, 2, 2, 2, 1654, 1652,
	3, 2, 2, 2, 1654, 1655, 3, 2, 2, 2, 1655, 349, 3, 2, 2, 2, 1656, 1658,
	5, 348, 175, 2, 1657, 1656, 3, 2, 2, 2, 1657, 1658, 3, 2, 2, 2, 1658, 1660,
	3, 2, 2, 2, 1659, 1661, 5, 342, 172, 2, 1660, 1659, 3, 2, 2, 2, 1661, 1662,
	3, 2, 2, 2, 1662, 1660, 3, 2, 2, 2, 1662, 1663, 3, 2, 2, 2, 1663, 1664,
	3, 2, 2, 2, 1664, 1665, 7, 2, 2, 3, 1665, 351, 3, 2, 2, 2, 186, 358, 365,
	376, 389, 400, 410, 414, 422, 432, 436, 441, 445, 450, 454, 461, 468, 479,
	487, 489, 492, 495, 499, 505, 513, 519, 524, 527, 529, 539, 541, 546, 551,
	556, 566, 572, 581, 583, 586, 597, 602, 605, 614, 618, 625, 630, 639, 652,
	655, 663, 668, 676, 685, 691, 693, 700, 712, 714, 720, 722, 730, 739, 743,
	752, 759, 766, 775, 785, 798, 805, 808, 815, 825, 834, 837, 844, 851, 867,
	870, 874, 877, 880, 887, 896, 899, 902, 910, 914, 916, 920, 926, 928, 936,
	944, 956, 962, 965, 986, 997, 1001, 1006, 1009, 1017, 1021, 1027, 1035,
	1039, 1043, 1049, 1060, 1066, 1072, 1079, 1087, 1098, 1108, 1115, 1125,
	1142, 1147, 1151, 1156, 1162, 1170, 1176, 1180, 1196, 1205, 1225, 1231,
	1251, 1257, 1265, 1268, 1279, 1289, 1300, 1308, 1316, 1324, 1332, 1340,
	1348, 1356, 1361, 1378, 1386, 1392, 1398, 1406, 1409, 1418, 1424, 1433,
	1462, 1466, 1476, 1481, 1490, 1497, 1501, 1509, 1528, 1540, 1543, 1550,
	1555, 1561, 1566, 1572, 1577, 1581, 1599, 1601, 1605, 1610, 1628, 1631,
	1636, 1640, 1645, 1649, 1654, 1657, 1662,
}

var literalNames = []string{
	"", "", "", "", "", "'!wrap'", "'!table'", "'!type'", "'!alias'", "'!union'",
	"'!view'", "", "", "", "", "", "", "", "", "", "", "", "", "'..'", "",
	"", "", "", "'<->'", "", "", "", "", "", "'.. * <- *'", "", "", "", "",
	"", "", "", "", "", "'@'", "", "", "", "", "", "", "", "", "'#'", "'|'",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "'=>'", "'->'", "'=='", "", "", "", "'<'", "'>'", "'{:}'", "",
	"", "'?.'", "", "'**'", "", "", "", "", "", "", "", "", "'%'", "'-'", "",
	"", "'!'", "", "'||'", "'&&'", "", "'by'", "'and'", "", "'*'", "'as'",
	"'via'", "'if'", "'then'", "'else'", "'let'", "'true'", "'false'", "'null'",
	"", "", "", "'asc'", "'desc'", "'rank'", "", "'any'", "", "'snapshot'",
	"'where'", "'count'", "'flatten'", "'first'",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "NativeDataTypes", "HTTP_VERBS", "WRAP", "TABLE",
	"TYPE", "ALIAS", "UNION", "VIEW", "IMPORT", "AS", "RETURN", "IF", "FOR_EACH",
	"FOR", "UNTIL", "ELSE", "LOOP", "ALT", "WHILE", "WHATEVER", "DOTDOT", "SEQUENCE_OF",
	"SET_OF", "ONE_OF", "MIXIN", "DISTANCE", "DOT_ARROW", "NAME_SEP", "LESS_COLON",
	"ARROW_LEFT", "ARROW_RIGHT", "COLLECTOR", "PLUS", "ABSTRACT", "TILDE",
	"COMMA", "EQ", "FORWARD_SLASH", "COLON", "DOT", "QN", "AT", "AMP", "SQ_OPEN",
	"SQ_CLOSE", "CURLY_OPEN", "CURLY_CLOSE", "OPEN_PAREN", "CLOSE_PAREN", "EMPTY_COMMENT",
	"HASH", "PIPE", "EMPTY_LINE", "INDENTED_COMMENT", "DIGITS", "QSTRING",
	"NEWLINE", "SYSL_COMMENT", "TEXT_LINE", "Name", "WS", "ErrorChar", "PREDICATE_VALUE",
	"SKIP_WS_ARG", "TEXT_VALUE", "NEWLINE_2", "TEXT", "POP_WS", "VAR_NAME",
	"E_NativeDataTypes", "E_INDENTED_COMMENT", "E_WHATEVER", "E_EQ_RIGHT",
	"E_ARROW_RIGHT", "E_DOUBLE_EQ", "E_REL", "E_SQ_OPEN", "E_SQ_CLOSE", "E_ANGLE_OPEN",
	"E_ANGLE_CLOSE", "E_EMPTY_TUPLE", "E_CURLY_OPEN", "E_CURLY_CLOSE", "E_NULLSAFE_DOT",
	"E_TABLE_OF", "E_POW", "E_COALESCE", "E_COLON", "E_OPEN_PAREN", "E_CLOSE_PAREN",
	"E_COMMA", "E_EQ", "E_PLUS", "E_DIVIDE", "E_MOD", "E_MINUS", "E_QN", "E_TILDE",
	"E_NOT", "E_XOR", "E_LOGIC_OR", "E_DOUBLE_AMP", "E_AMP", "E_BY", "E_AND",
	"E_BITOR", "E_STAR", "E_AS", "E_VIA", "E_IF", "E_THEN", "E_ELSE", "E_LET",
	"E_TRUE", "E_FALSE", "E_NULL", "E_BUTNOT", "E_SEQUENCE_OF", "E_SET_OF",
	"E_ASC", "E_DESC", "E_RELOPS_RANK", "E_RELOPS_AGG", "E_RELOPS_ANY", "E_RELOPS_SINGLE_NULL",
	"E_RELOPS_SNAPSHOT", "E_RELOPS_WHERE", "E_RELOPS_COUNT", "E_RELOPS_FLATTEN",
	"E_RELOPS_FIRST", "E_FUNC", "E_STRING_DBL", "E_STRING_SINGLE", "E_DECIMAL",
	"E_DIGITS", "E_DOT_NAME_NL", "E_Name", "E_DOT", "E_WS", "E_EMPTY_LINE",
	"E_NL", "IMPORT_PATH",
}

var ruleNames = []string{
	"modifier", "size_spec", "name_str", "reference", "doc_string", "quoted_string",
	"array_of_strings", "array_of_arrays", "nvp", "entry", "attribs_or_modifiers",
	"user_defined_type", "types", "set_of", "set_type", "sequence_of", "sequence_type",
	"collection_type", "multi_line_docstring", "annotation_value", "annotation",
	"annotations", "field_type", "array_size", "inplace_tuple", "field", "inplace_table",
	"table_stmts", "table_def", "table", "union", "package_name", "sub_package",
	"app_name", "name_with_attribs", "model_name", "inplace_table_def", "table_refs",
	"facade", "var_in_curly", "query_var", "query_param", "http_path_part",
	"http_path_var_with_type", "http_path_static", "http_path_suffix", "http_path",
	"endpoint_name", "ret_stmt", "target", "target_endpoint", "call_arg", "call_args",
	"call_stmt", "if_stmt", "else_stmt", "if_else", "for_stmt", "http_method_comment",
	"group_stmt", "one_of_case_label", "one_of_cases", "one_of_stmt", "text_stmt",
	"mixin", "param", "param_list", "params", "statements", "method_def", "shortcut",
	"simple_endpoint", "rest_endpoint", "collector_query_var", "collector_query_param",
	"collector_call_stmt", "collector_http_stmt_part", "collector_http_stmt_suffix",
	"collector_http_stmt", "publisher", "subscriber", "collector_pubsub_call",
	"collector_action_stmt", "collector_stmts", "collector", "event", "subscribe",
	"view_type_spec", "literal", "expr_table_of_op", "func_arg", "func_args",
	"expr_func", "rank_expr", "rank_expr_list", "expr_rank_func", "expr_agg_func",
	"e_scope_var", "first_func_target", "expr_first_func", "e_single_arg_func",
	"expr_single_arg_func", "expr_any_func", "expr_single_or_null", "expr_snapshot",
	"expr_count", "expr_navigate_attr", "expr_navigate", "matching_rhs", "squiggly_args",
	"expr_matching", "relop", "list_item", "expr_list", "expr_set", "empty_tuple",
	"atom_dot_relop", "atomT_implied_dot", "atomT_name", "atomT_paren", "expr_atom_list",
	"atomT", "atom", "powerT", "power", "unaryTerm", "termT", "term", "binexprT",
	"binexpr", "e_compare_ops", "expr_rel", "expr_bitand", "expr_bitxor", "expr_bitor",
	"expr_and", "expr_or", "expr_but_not", "expr_coalesce", "if_one_liner",
	"else_block_stmt", "control_item", "if_controls", "cond_block", "final_else",
	"ifvar", "if_multiple_lines", "expr_if_else", "expr", "expr_assign", "expr_simple_assign",
	"expr_let_statement", "expr_table_of_statement", "expr_dot_assign", "expr_statement_no_nl",
	"expr_statement", "expr_inject_stmt", "expr_stmt", "transform_return_type",
	"view_return_type", "transform_scope_var", "transform_arg", "transform",
	"expr_block", "view_param", "view_params", "abstract_view", "view", "alias",
	"app_decl", "application", "import_mode", "import_stmt", "imports_decl",
	"sysl_file",
}

type SyslParser struct {
	*antlr.BaseParser
}

func NewSyslParser(input antlr.TokenStream) *SyslParser {
	this := new(SyslParser)

	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SyslParser.g4"

	return this
}

// SyslParser tokens.
const (
	SyslParserEOF                  = antlr.TokenEOF
	SyslParserINDENT               = 1
	SyslParserDEDENT               = 2
	SyslParserNativeDataTypes      = 3
	SyslParserHTTP_VERBS           = 4
	SyslParserWRAP                 = 5
	SyslParserTABLE                = 6
	SyslParserTYPE                 = 7
	SyslParserALIAS                = 8
	SyslParserUNION                = 9
	SyslParserVIEW                 = 10
	SyslParserIMPORT               = 11
	SyslParserAS                   = 12
	SyslParserRETURN               = 13
	SyslParserIF                   = 14
	SyslParserFOR_EACH             = 15
	SyslParserFOR                  = 16
	SyslParserUNTIL                = 17
	SyslParserELSE                 = 18
	SyslParserLOOP                 = 19
	SyslParserALT                  = 20
	SyslParserWHILE                = 21
	SyslParserWHATEVER             = 22
	SyslParserDOTDOT               = 23
	SyslParserSEQUENCE_OF          = 24
	SyslParserSET_OF               = 25
	SyslParserONE_OF               = 26
	SyslParserMIXIN                = 27
	SyslParserDISTANCE             = 28
	SyslParserDOT_ARROW            = 29
	SyslParserNAME_SEP             = 30
	SyslParserLESS_COLON           = 31
	SyslParserARROW_LEFT           = 32
	SyslParserARROW_RIGHT          = 33
	SyslParserCOLLECTOR            = 34
	SyslParserPLUS                 = 35
	SyslParserABSTRACT             = 36
	SyslParserTILDE                = 37
	SyslParserCOMMA                = 38
	SyslParserEQ                   = 39
	SyslParserFORWARD_SLASH        = 40
	SyslParserCOLON                = 41
	SyslParserDOT                  = 42
	SyslParserQN                   = 43
	SyslParserAT                   = 44
	SyslParserAMP                  = 45
	SyslParserSQ_OPEN              = 46
	SyslParserSQ_CLOSE             = 47
	SyslParserCURLY_OPEN           = 48
	SyslParserCURLY_CLOSE          = 49
	SyslParserOPEN_PAREN           = 50
	SyslParserCLOSE_PAREN          = 51
	SyslParserEMPTY_COMMENT        = 52
	SyslParserHASH                 = 53
	SyslParserPIPE                 = 54
	SyslParserEMPTY_LINE           = 55
	SyslParserINDENTED_COMMENT     = 56
	SyslParserDIGITS               = 57
	SyslParserQSTRING              = 58
	SyslParserNEWLINE              = 59
	SyslParserSYSL_COMMENT         = 60
	SyslParserTEXT_LINE            = 61
	SyslParserName                 = 62
	SyslParserWS                   = 63
	SyslParserErrorChar            = 64
	SyslParserPREDICATE_VALUE      = 65
	SyslParserSKIP_WS_ARG          = 66
	SyslParserTEXT_VALUE           = 67
	SyslParserNEWLINE_2            = 68
	SyslParserTEXT                 = 69
	SyslParserPOP_WS               = 70
	SyslParserVAR_NAME             = 71
	SyslParserE_NativeDataTypes    = 72
	SyslParserE_INDENTED_COMMENT   = 73
	SyslParserE_WHATEVER           = 74
	SyslParserE_EQ_RIGHT           = 75
	SyslParserE_ARROW_RIGHT        = 76
	SyslParserE_DOUBLE_EQ          = 77
	SyslParserE_REL                = 78
	SyslParserE_SQ_OPEN            = 79
	SyslParserE_SQ_CLOSE           = 80
	SyslParserE_ANGLE_OPEN         = 81
	SyslParserE_ANGLE_CLOSE        = 82
	SyslParserE_EMPTY_TUPLE        = 83
	SyslParserE_CURLY_OPEN         = 84
	SyslParserE_CURLY_CLOSE        = 85
	SyslParserE_NULLSAFE_DOT       = 86
	SyslParserE_TABLE_OF           = 87
	SyslParserE_POW                = 88
	SyslParserE_COALESCE           = 89
	SyslParserE_COLON              = 90
	SyslParserE_OPEN_PAREN         = 91
	SyslParserE_CLOSE_PAREN        = 92
	SyslParserE_COMMA              = 93
	SyslParserE_EQ                 = 94
	SyslParserE_PLUS               = 95
	SyslParserE_DIVIDE             = 96
	SyslParserE_MOD                = 97
	SyslParserE_MINUS              = 98
	SyslParserE_QN                 = 99
	SyslParserE_TILDE              = 100
	SyslParserE_NOT                = 101
	SyslParserE_XOR                = 102
	SyslParserE_LOGIC_OR           = 103
	SyslParserE_DOUBLE_AMP         = 104
	SyslParserE_AMP                = 105
	SyslParserE_BY                 = 106
	SyslParserE_AND                = 107
	SyslParserE_BITOR              = 108
	SyslParserE_STAR               = 109
	SyslParserE_AS                 = 110
	SyslParserE_VIA                = 111
	SyslParserE_IF                 = 112
	SyslParserE_THEN               = 113
	SyslParserE_ELSE               = 114
	SyslParserE_LET                = 115
	SyslParserE_TRUE               = 116
	SyslParserE_FALSE              = 117
	SyslParserE_NULL               = 118
	SyslParserE_BUTNOT             = 119
	SyslParserE_SEQUENCE_OF        = 120
	SyslParserE_SET_OF             = 121
	SyslParserE_ASC                = 122
	SyslParserE_DESC               = 123
	SyslParserE_RELOPS_RANK        = 124
	SyslParserE_RELOPS_AGG         = 125
	SyslParserE_RELOPS_ANY         = 126
	SyslParserE_RELOPS_SINGLE_NULL = 127
	SyslParserE_RELOPS_SNAPSHOT    = 128
	SyslParserE_RELOPS_WHERE       = 129
	SyslParserE_RELOPS_COUNT       = 130
	SyslParserE_RELOPS_FLATTEN     = 131
	SyslParserE_RELOPS_FIRST       = 132
	SyslParserE_FUNC               = 133
	SyslParserE_STRING_DBL         = 134
	SyslParserE_STRING_SINGLE      = 135
	SyslParserE_DECIMAL            = 136
	SyslParserE_DIGITS             = 137
	SyslParserE_DOT_NAME_NL        = 138
	SyslParserE_Name               = 139
	SyslParserE_DOT                = 140
	SyslParserE_WS                 = 141
	SyslParserE_EMPTY_LINE         = 142
	SyslParserE_NL                 = 143
	SyslParserIMPORT_PATH          = 144
)

// SyslParser rules.
const (
	SyslParserRULE_modifier                   = 0
	SyslParserRULE_size_spec                  = 1
	SyslParserRULE_name_str                   = 2
	SyslParserRULE_reference                  = 3
	SyslParserRULE_doc_string                 = 4
	SyslParserRULE_quoted_string              = 5
	SyslParserRULE_array_of_strings           = 6
	SyslParserRULE_array_of_arrays            = 7
	SyslParserRULE_nvp                        = 8
	SyslParserRULE_entry                      = 9
	SyslParserRULE_attribs_or_modifiers       = 10
	SyslParserRULE_user_defined_type          = 11
	SyslParserRULE_types                      = 12
	SyslParserRULE_set_of                     = 13
	SyslParserRULE_set_type                   = 14
	SyslParserRULE_sequence_of                = 15
	SyslParserRULE_sequence_type              = 16
	SyslParserRULE_collection_type            = 17
	SyslParserRULE_multi_line_docstring       = 18
	SyslParserRULE_annotation_value           = 19
	SyslParserRULE_annotation                 = 20
	SyslParserRULE_annotations                = 21
	SyslParserRULE_field_type                 = 22
	SyslParserRULE_array_size                 = 23
	SyslParserRULE_inplace_tuple              = 24
	SyslParserRULE_field                      = 25
	SyslParserRULE_inplace_table              = 26
	SyslParserRULE_table_stmts                = 27
	SyslParserRULE_table_def                  = 28
	SyslParserRULE_table                      = 29
	SyslParserRULE_union                      = 30
	SyslParserRULE_package_name               = 31
	SyslParserRULE_sub_package                = 32
	SyslParserRULE_app_name                   = 33
	SyslParserRULE_name_with_attribs          = 34
	SyslParserRULE_model_name                 = 35
	SyslParserRULE_inplace_table_def          = 36
	SyslParserRULE_table_refs                 = 37
	SyslParserRULE_facade                     = 38
	SyslParserRULE_var_in_curly               = 39
	SyslParserRULE_query_var                  = 40
	SyslParserRULE_query_param                = 41
	SyslParserRULE_http_path_part             = 42
	SyslParserRULE_http_path_var_with_type    = 43
	SyslParserRULE_http_path_static           = 44
	SyslParserRULE_http_path_suffix           = 45
	SyslParserRULE_http_path                  = 46
	SyslParserRULE_endpoint_name              = 47
	SyslParserRULE_ret_stmt                   = 48
	SyslParserRULE_target                     = 49
	SyslParserRULE_target_endpoint            = 50
	SyslParserRULE_call_arg                   = 51
	SyslParserRULE_call_args                  = 52
	SyslParserRULE_call_stmt                  = 53
	SyslParserRULE_if_stmt                    = 54
	SyslParserRULE_else_stmt                  = 55
	SyslParserRULE_if_else                    = 56
	SyslParserRULE_for_stmt                   = 57
	SyslParserRULE_http_method_comment        = 58
	SyslParserRULE_group_stmt                 = 59
	SyslParserRULE_one_of_case_label          = 60
	SyslParserRULE_one_of_cases               = 61
	SyslParserRULE_one_of_stmt                = 62
	SyslParserRULE_text_stmt                  = 63
	SyslParserRULE_mixin                      = 64
	SyslParserRULE_param                      = 65
	SyslParserRULE_param_list                 = 66
	SyslParserRULE_params                     = 67
	SyslParserRULE_statements                 = 68
	SyslParserRULE_method_def                 = 69
	SyslParserRULE_shortcut                   = 70
	SyslParserRULE_simple_endpoint            = 71
	SyslParserRULE_rest_endpoint              = 72
	SyslParserRULE_collector_query_var        = 73
	SyslParserRULE_collector_query_param      = 74
	SyslParserRULE_collector_call_stmt        = 75
	SyslParserRULE_collector_http_stmt_part   = 76
	SyslParserRULE_collector_http_stmt_suffix = 77
	SyslParserRULE_collector_http_stmt        = 78
	SyslParserRULE_publisher                  = 79
	SyslParserRULE_subscriber                 = 80
	SyslParserRULE_collector_pubsub_call      = 81
	SyslParserRULE_collector_action_stmt      = 82
	SyslParserRULE_collector_stmts            = 83
	SyslParserRULE_collector                  = 84
	SyslParserRULE_event                      = 85
	SyslParserRULE_subscribe                  = 86
	SyslParserRULE_view_type_spec             = 87
	SyslParserRULE_literal                    = 88
	SyslParserRULE_expr_table_of_op           = 89
	SyslParserRULE_func_arg                   = 90
	SyslParserRULE_func_args                  = 91
	SyslParserRULE_expr_func                  = 92
	SyslParserRULE_rank_expr                  = 93
	SyslParserRULE_rank_expr_list             = 94
	SyslParserRULE_expr_rank_func             = 95
	SyslParserRULE_expr_agg_func              = 96
	SyslParserRULE_e_scope_var                = 97
	SyslParserRULE_first_func_target          = 98
	SyslParserRULE_expr_first_func            = 99
	SyslParserRULE_e_single_arg_func          = 100
	SyslParserRULE_expr_single_arg_func       = 101
	SyslParserRULE_expr_any_func              = 102
	SyslParserRULE_expr_single_or_null        = 103
	SyslParserRULE_expr_snapshot              = 104
	SyslParserRULE_expr_count                 = 105
	SyslParserRULE_expr_navigate_attr         = 106
	SyslParserRULE_expr_navigate              = 107
	SyslParserRULE_matching_rhs               = 108
	SyslParserRULE_squiggly_args              = 109
	SyslParserRULE_expr_matching              = 110
	SyslParserRULE_relop                      = 111
	SyslParserRULE_list_item                  = 112
	SyslParserRULE_expr_list                  = 113
	SyslParserRULE_expr_set                   = 114
	SyslParserRULE_empty_tuple                = 115
	SyslParserRULE_atom_dot_relop             = 116
	SyslParserRULE_atomT_implied_dot          = 117
	SyslParserRULE_atomT_name                 = 118
	SyslParserRULE_atomT_paren                = 119
	SyslParserRULE_expr_atom_list             = 120
	SyslParserRULE_atomT                      = 121
	SyslParserRULE_atom                       = 122
	SyslParserRULE_powerT                     = 123
	SyslParserRULE_power                      = 124
	SyslParserRULE_unaryTerm                  = 125
	SyslParserRULE_termT                      = 126
	SyslParserRULE_term                       = 127
	SyslParserRULE_binexprT                   = 128
	SyslParserRULE_binexpr                    = 129
	SyslParserRULE_e_compare_ops              = 130
	SyslParserRULE_expr_rel                   = 131
	SyslParserRULE_expr_bitand                = 132
	SyslParserRULE_expr_bitxor                = 133
	SyslParserRULE_expr_bitor                 = 134
	SyslParserRULE_expr_and                   = 135
	SyslParserRULE_expr_or                    = 136
	SyslParserRULE_expr_but_not               = 137
	SyslParserRULE_expr_coalesce              = 138
	SyslParserRULE_if_one_liner               = 139
	SyslParserRULE_else_block_stmt            = 140
	SyslParserRULE_control_item               = 141
	SyslParserRULE_if_controls                = 142
	SyslParserRULE_cond_block                 = 143
	SyslParserRULE_final_else                 = 144
	SyslParserRULE_ifvar                      = 145
	SyslParserRULE_if_multiple_lines          = 146
	SyslParserRULE_expr_if_else               = 147
	SyslParserRULE_expr                       = 148
	SyslParserRULE_expr_assign                = 149
	SyslParserRULE_expr_simple_assign         = 150
	SyslParserRULE_expr_let_statement         = 151
	SyslParserRULE_expr_table_of_statement    = 152
	SyslParserRULE_expr_dot_assign            = 153
	SyslParserRULE_expr_statement_no_nl       = 154
	SyslParserRULE_expr_statement             = 155
	SyslParserRULE_expr_inject_stmt           = 156
	SyslParserRULE_expr_stmt                  = 157
	SyslParserRULE_transform_return_type      = 158
	SyslParserRULE_view_return_type           = 159
	SyslParserRULE_transform_scope_var        = 160
	SyslParserRULE_transform_arg              = 161
	SyslParserRULE_transform                  = 162
	SyslParserRULE_expr_block                 = 163
	SyslParserRULE_view_param                 = 164
	SyslParserRULE_view_params                = 165
	SyslParserRULE_abstract_view              = 166
	SyslParserRULE_view                       = 167
	SyslParserRULE_alias                      = 168
	SyslParserRULE_app_decl                   = 169
	SyslParserRULE_application                = 170
	SyslParserRULE_import_mode                = 171
	SyslParserRULE_import_stmt                = 172
	SyslParserRULE_imports_decl               = 173
	SyslParserRULE_sysl_file                  = 174
)

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *ModifierContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *ModifierContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *ModifierContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserPLUS)
}

func (s *ModifierContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserPLUS, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *SyslParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SyslParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(351)
		p.Match(SyslParserName)
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserPLUS {
		{
			p.SetState(352)
			p.Match(SyslParserPLUS)
		}
		{
			p.SetState(353)
			p.Match(SyslParserName)
		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISize_specContext is an interface to support dynamic dispatch.
type ISize_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSize_specContext differentiates from other interfaces.
	IsSize_specContext()
}

type Size_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySize_specContext() *Size_specContext {
	var p = new(Size_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_size_spec
	return p
}

func (*Size_specContext) IsSize_specContext() {}

func NewSize_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Size_specContext {
	var p = new(Size_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_size_spec

	return p
}

func (s *Size_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Size_specContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Size_specContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Size_specContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Size_specContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Size_specContext) DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, 0)
}

func (s *Size_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Size_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Size_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSize_spec(s)
	}
}

func (s *Size_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSize_spec(s)
	}
}

func (p *SyslParser) Size_spec() (localctx ISize_specContext) {
	localctx = NewSize_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SyslParserRULE_size_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(360)
		p.Match(SyslParserDIGITS)
	}
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDOT {
		{
			p.SetState(361)
			p.Match(SyslParserDOT)
		}
		{
			p.SetState(362)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(365)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IName_strContext is an interface to support dynamic dispatch.
type IName_strContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_strContext differentiates from other interfaces.
	IsName_strContext()
}

type Name_strContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_strContext() *Name_strContext {
	var p = new(Name_strContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_str
	return p
}

func (*Name_strContext) IsName_strContext() {}

func NewName_strContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_strContext {
	var p = new(Name_strContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_str

	return p
}

func (s *Name_strContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_strContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Name_strContext) TEXT_LINE() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, 0)
}

func (s *Name_strContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Name_strContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_strContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_strContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_str(s)
	}
}

func (s *Name_strContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_str(s)
	}
}

func (p *SyslParser) Name_str() (localctx IName_strContext) {
	localctx = NewName_strContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SyslParserRULE_name_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(367)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *ReferenceContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *ReferenceContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ReferenceContext) AllE_DOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOT)
}

func (s *ReferenceContext) E_DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, i)
}

func (s *ReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *ReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *SyslParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SyslParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.App_name()
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(370)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserDOT || _la == SyslParserE_DOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(371)
				p.Name_str()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}

	return localctx
}

// IDoc_stringContext is an interface to support dynamic dispatch.
type IDoc_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoc_stringContext differentiates from other interfaces.
	IsDoc_stringContext()
}

type Doc_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoc_stringContext() *Doc_stringContext {
	var p = new(Doc_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_doc_string
	return p
}

func (*Doc_stringContext) IsDoc_stringContext() {}

func NewDoc_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Doc_stringContext {
	var p = new(Doc_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_doc_string

	return p
}

func (s *Doc_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Doc_stringContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SyslParserPIPE, 0)
}

func (s *Doc_stringContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Doc_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Doc_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Doc_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDoc_string(s)
	}
}

func (s *Doc_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDoc_string(s)
	}
}

func (p *SyslParser) Doc_string() (localctx IDoc_stringContext) {
	localctx = NewDoc_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SyslParserRULE_doc_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(SyslParserPIPE)
	}
	{
		p.SetState(377)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *SyslParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SyslParserRULE_quoted_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(SyslParserQSTRING)
	}

	return localctx
}

// IArray_of_stringsContext is an interface to support dynamic dispatch.
type IArray_of_stringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_stringsContext differentiates from other interfaces.
	IsArray_of_stringsContext()
}

type Array_of_stringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_stringsContext() *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_strings
	return p
}

func (*Array_of_stringsContext) IsArray_of_stringsContext() {}

func NewArray_of_stringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_strings

	return p
}

func (s *Array_of_stringsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_stringsContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_stringsContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *Array_of_stringsContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Array_of_stringsContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_stringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_stringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_stringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_stringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_stringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_strings(s)
	}
}

func (s *Array_of_stringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_strings(s)
	}
}

func (p *SyslParser) Array_of_strings() (localctx IArray_of_stringsContext) {
	localctx = NewArray_of_stringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SyslParserRULE_array_of_strings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(382)
		p.Quoted_string()
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(383)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(384)
			p.Quoted_string()
		}

		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(390)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IArray_of_arraysContext is an interface to support dynamic dispatch.
type IArray_of_arraysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_arraysContext differentiates from other interfaces.
	IsArray_of_arraysContext()
}

type Array_of_arraysContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_arraysContext() *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_arrays
	return p
}

func (*Array_of_arraysContext) IsArray_of_arraysContext() {}

func NewArray_of_arraysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_arrays

	return p
}

func (s *Array_of_arraysContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_arraysContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_arraysContext) AllArray_of_strings() []IArray_of_stringsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem())
	var tst = make([]IArray_of_stringsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArray_of_stringsContext)
		}
	}

	return tst
}

func (s *Array_of_arraysContext) Array_of_strings(i int) IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Array_of_arraysContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_arraysContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_arraysContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_arraysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_arraysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_arraysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_arrays(s)
	}
}

func (s *Array_of_arraysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_arrays(s)
	}
}

func (p *SyslParser) Array_of_arrays() (localctx IArray_of_arraysContext) {
	localctx = NewArray_of_arraysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SyslParserRULE_array_of_arrays)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(393)
		p.Array_of_strings()
	}
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(394)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(395)
			p.Array_of_strings()
		}

		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(401)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// INvpContext is an interface to support dynamic dispatch.
type INvpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNvpContext differentiates from other interfaces.
	IsNvpContext()
}

type NvpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNvpContext() *NvpContext {
	var p = new(NvpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_nvp
	return p
}

func (*NvpContext) IsNvpContext() {}

func NewNvpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NvpContext {
	var p = new(NvpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_nvp

	return p
}

func (s *NvpContext) GetParser() antlr.Parser { return s.parser }

func (s *NvpContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *NvpContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *NvpContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *NvpContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *NvpContext) Array_of_arrays() IArray_of_arraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_arraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_arraysContext)
}

func (s *NvpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NvpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NvpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterNvp(s)
	}
}

func (s *NvpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitNvp(s)
	}
}

func (p *SyslParser) Nvp() (localctx INvpContext) {
	localctx = NewNvpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SyslParserRULE_nvp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.Match(SyslParserName)
	}
	{
		p.SetState(404)
		p.Match(SyslParserEQ)
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(405)
			p.Quoted_string()
		}

	case 2:
		{
			p.SetState(406)
			p.Array_of_strings()
		}

	case 3:
		{
			p.SetState(407)
			p.Array_of_arrays()
		}

	}

	return localctx
}

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_entry
	return p
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) Nvp() INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *EntryContext) Modifier() IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEntry(s)
	}
}

func (s *EntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEntry(s)
	}
}

func (p *SyslParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SyslParserRULE_entry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(412)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(410)
			p.Nvp()
		}

	case SyslParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(411)
			p.Modifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribs_or_modifiersContext is an interface to support dynamic dispatch.
type IAttribs_or_modifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribs_or_modifiersContext differentiates from other interfaces.
	IsAttribs_or_modifiersContext()
}

type Attribs_or_modifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribs_or_modifiersContext() *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers
	return p
}

func (*Attribs_or_modifiersContext) IsAttribs_or_modifiersContext() {}

func NewAttribs_or_modifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers

	return p
}

func (s *Attribs_or_modifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribs_or_modifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Attribs_or_modifiersContext) AllEntry() []IEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntryContext)(nil)).Elem())
	var tst = make([]IEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntryContext)
		}
	}

	return tst
}

func (s *Attribs_or_modifiersContext) Entry(i int) IEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntryContext)
}

func (s *Attribs_or_modifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Attribs_or_modifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Attribs_or_modifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Attribs_or_modifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribs_or_modifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribs_or_modifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttribs_or_modifiers(s)
	}
}

func (s *Attribs_or_modifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttribs_or_modifiers(s)
	}
}

func (p *SyslParser) Attribs_or_modifiers() (localctx IAttribs_or_modifiersContext) {
	localctx = NewAttribs_or_modifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SyslParserRULE_attribs_or_modifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(415)
		p.Entry()
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(416)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(417)
			p.Entry()
		}

		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(423)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IUser_defined_typeContext is an interface to support dynamic dispatch.
type IUser_defined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_defined_typeContext differentiates from other interfaces.
	IsUser_defined_typeContext()
}

type User_defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_defined_typeContext() *User_defined_typeContext {
	var p = new(User_defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_user_defined_type
	return p
}

func (*User_defined_typeContext) IsUser_defined_typeContext() {}

func NewUser_defined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_defined_typeContext {
	var p = new(User_defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_user_defined_type

	return p
}

func (s *User_defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_defined_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *User_defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUser_defined_type(s)
	}
}

func (s *User_defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUser_defined_type(s)
	}
}

func (p *SyslParser) User_defined_type() (localctx IUser_defined_typeContext) {
	localctx = NewUser_defined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SyslParserRULE_user_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Name_str()
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) User_defined_type() IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *TypesContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *TypesContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SyslParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SyslParserRULE_types)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(427)
			p.User_defined_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(428)
			p.Reference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(429)
			p.Match(SyslParserNativeDataTypes)
		}

	}

	return localctx
}

// ISet_ofContext is an interface to support dynamic dispatch.
type ISet_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_ofContext differentiates from other interfaces.
	IsSet_ofContext()
}

type Set_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_ofContext() *Set_ofContext {
	var p = new(Set_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_of
	return p
}

func (*Set_ofContext) IsSet_ofContext() {}

func NewSet_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_ofContext {
	var p = new(Set_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_of

	return p
}

func (s *Set_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_ofContext) SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSET_OF, 0)
}

func (s *Set_ofContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Set_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_of(s)
	}
}

func (s *Set_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_of(s)
	}
}

func (p *SyslParser) Set_of() (localctx ISet_ofContext) {
	localctx = NewSet_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SyslParserRULE_set_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(434)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.Match(SyslParserSET_OF)
		}

	case SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.Match(SyslParserE_SET_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_type
	return p
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Set_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Set_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (p *SyslParser) Set_type() (localctx ISet_typeContext) {
	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SyslParserRULE_set_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Set_of()
	}
	{
		p.SetState(437)
		p.Types()
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(438)
			p.Size_spec()
		}

	}

	return localctx
}

// ISequence_ofContext is an interface to support dynamic dispatch.
type ISequence_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_ofContext differentiates from other interfaces.
	IsSequence_ofContext()
}

type Sequence_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_ofContext() *Sequence_ofContext {
	var p = new(Sequence_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_of
	return p
}

func (*Sequence_ofContext) IsSequence_ofContext() {}

func NewSequence_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_ofContext {
	var p = new(Sequence_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_of

	return p
}

func (s *Sequence_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_ofContext) SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_of(s)
	}
}

func (s *Sequence_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_of(s)
	}
}

func (p *SyslParser) Sequence_of() (localctx ISequence_ofContext) {
	localctx = NewSequence_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SyslParserRULE_sequence_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(443)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(441)
			p.Match(SyslParserSEQUENCE_OF)
		}

	case SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(442)
			p.Match(SyslParserE_SEQUENCE_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_typeContext is an interface to support dynamic dispatch.
type ISequence_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_typeContext differentiates from other interfaces.
	IsSequence_typeContext()
}

type Sequence_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_typeContext() *Sequence_typeContext {
	var p = new(Sequence_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_type
	return p
}

func (*Sequence_typeContext) IsSequence_typeContext() {}

func NewSequence_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_typeContext {
	var p = new(Sequence_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_type

	return p
}

func (s *Sequence_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Sequence_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Sequence_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Sequence_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_type(s)
	}
}

func (s *Sequence_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_type(s)
	}
}

func (p *SyslParser) Sequence_type() (localctx ISequence_typeContext) {
	localctx = NewSequence_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SyslParserRULE_sequence_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.Sequence_of()
	}
	{
		p.SetState(446)
		p.Types()
	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(447)
			p.Size_spec()
		}

	}

	return localctx
}

// ICollection_typeContext is an interface to support dynamic dispatch.
type ICollection_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_typeContext differentiates from other interfaces.
	IsCollection_typeContext()
}

type Collection_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_typeContext() *Collection_typeContext {
	var p = new(Collection_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collection_type
	return p
}

func (*Collection_typeContext) IsCollection_typeContext() {}

func NewCollection_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_typeContext {
	var p = new(Collection_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collection_type

	return p
}

func (s *Collection_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_typeContext) Set_type() ISet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Collection_typeContext) Sequence_type() ISequence_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_typeContext)
}

func (s *Collection_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollection_type(s)
	}
}

func (s *Collection_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollection_type(s)
	}
}

func (p *SyslParser) Collection_type() (localctx ICollection_typeContext) {
	localctx = NewCollection_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SyslParserRULE_collection_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(452)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(450)
			p.Set_type()
		}

	case SyslParserSEQUENCE_OF, SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(451)
			p.Sequence_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMulti_line_docstringContext is an interface to support dynamic dispatch.
type IMulti_line_docstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_line_docstringContext differentiates from other interfaces.
	IsMulti_line_docstringContext()
}

type Multi_line_docstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_line_docstringContext() *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_multi_line_docstring
	return p
}

func (*Multi_line_docstringContext) IsMulti_line_docstringContext() {}

func NewMulti_line_docstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_multi_line_docstring

	return p
}

func (s *Multi_line_docstringContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_line_docstringContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Multi_line_docstringContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Multi_line_docstringContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Multi_line_docstringContext) AllDoc_string() []IDoc_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem())
	var tst = make([]IDoc_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDoc_stringContext)
		}
	}

	return tst
}

func (s *Multi_line_docstringContext) Doc_string(i int) IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Multi_line_docstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_line_docstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_line_docstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMulti_line_docstring(s)
	}
}

func (s *Multi_line_docstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMulti_line_docstring(s)
	}
}

func (p *SyslParser) Multi_line_docstring() (localctx IMulti_line_docstringContext) {
	localctx = NewMulti_line_docstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SyslParserRULE_multi_line_docstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(455)
		p.Match(SyslParserINDENT)
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserPIPE {
		{
			p.SetState(456)
			p.Doc_string()
		}

		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(461)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IAnnotation_valueContext is an interface to support dynamic dispatch.
type IAnnotation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_valueContext differentiates from other interfaces.
	IsAnnotation_valueContext()
}

type Annotation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_valueContext() *Annotation_valueContext {
	var p = new(Annotation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation_value
	return p
}

func (*Annotation_valueContext) IsAnnotation_valueContext() {}

func NewAnnotation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_valueContext {
	var p = new(Annotation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation_value

	return p
}

func (s *Annotation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_valueContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Annotation_valueContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Annotation_valueContext) Multi_line_docstring() IMulti_line_docstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_line_docstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_line_docstringContext)
}

func (s *Annotation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation_value(s)
	}
}

func (s *Annotation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation_value(s)
	}
}

func (p *SyslParser) Annotation_value() (localctx IAnnotation_valueContext) {
	localctx = NewAnnotation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SyslParserRULE_annotation_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(466)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserSQ_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Array_of_strings()
		}

	case SyslParserCOLON:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(465)
			p.Multi_line_docstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *AnnotationContext) VAR_NAME() antlr.TerminalNode {
	return s.GetToken(SyslParserVAR_NAME, 0)
}

func (s *AnnotationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *AnnotationContext) Annotation_value() IAnnotation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_valueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *SyslParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SyslParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(469)
		p.Match(SyslParserVAR_NAME)
	}
	{
		p.SetState(470)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(471)
		p.Annotation_value()
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AnnotationsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AnnotationsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (p *SyslParser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SyslParserRULE_annotations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(473)
		p.Match(SyslParserINDENT)
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserAT {
		{
			p.SetState(474)
			p.Annotation()
		}

		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(479)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IField_typeContext is an interface to support dynamic dispatch.
type IField_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_typeContext differentiates from other interfaces.
	IsField_typeContext()
}

type Field_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_typeContext() *Field_typeContext {
	var p = new(Field_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field_type
	return p
}

func (*Field_typeContext) IsField_typeContext() {}

func NewField_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_typeContext {
	var p = new(Field_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field_type

	return p
}

func (s *Field_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_typeContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *Field_typeContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Field_typeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Field_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Field_typeContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Field_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Field_typeContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *Field_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Field_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField_type(s)
	}
}

func (s *Field_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField_type(s)
	}
}

func (p *SyslParser) Field_type() (localctx IField_typeContext) {
	localctx = NewField_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SyslParserRULE_field_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(487)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		{
			p.SetState(481)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(482)
			p.Types()
		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(483)
				p.Array_size()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(484)
				p.Size_spec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(489)
			p.Match(SyslParserQN)
		}

	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(492)
			p.Attribs_or_modifiers()
		}

	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(495)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(496)
			p.Annotations()
		}

	}

	return localctx
}

// IArray_sizeContext is an interface to support dynamic dispatch.
type IArray_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_sizeContext differentiates from other interfaces.
	IsArray_sizeContext()
}

type Array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_sizeContext() *Array_sizeContext {
	var p = new(Array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_size
	return p
}

func (*Array_sizeContext) IsArray_sizeContext() {}

func NewArray_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_sizeContext {
	var p = new(Array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_size

	return p
}

func (s *Array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_sizeContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Array_sizeContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Array_sizeContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Array_sizeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOTDOT, 0)
}

func (s *Array_sizeContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_size(s)
	}
}

func (s *Array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_size(s)
	}
}

func (p *SyslParser) Array_size() (localctx IArray_sizeContext) {
	localctx = NewArray_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SyslParserRULE_array_size)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(500)
		p.Match(SyslParserDIGITS)
	}
	{
		p.SetState(501)
		p.Match(SyslParserDOTDOT)
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDIGITS {
		{
			p.SetState(502)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(505)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IInplace_tupleContext is an interface to support dynamic dispatch.
type IInplace_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tupleContext differentiates from other interfaces.
	IsInplace_tupleContext()
}

type Inplace_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tupleContext() *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_tuple
	return p
}

func (*Inplace_tupleContext) IsInplace_tupleContext() {}

func NewInplace_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_tuple

	return p
}

func (s *Inplace_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tupleContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_tupleContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_tupleContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Inplace_tupleContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Inplace_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_tuple(s)
	}
}

func (s *Inplace_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_tuple(s)
	}
}

func (p *SyslParser) Inplace_tuple() (localctx IInplace_tupleContext) {
	localctx = NewInplace_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SyslParserRULE_inplace_tuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Match(SyslParserINDENT)
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
		{
			p.SetState(508)
			p.Field()
		}

		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(513)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *FieldContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *FieldContext) Field_type() IField_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_typeContext)
}

func (s *FieldContext) Inplace_tuple() IInplace_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_tupleContext)
}

func (s *FieldContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *FieldContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *SyslParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SyslParserRULE_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Name_str()
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserLESS_COLON || _la == SyslParserOPEN_PAREN {
		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(516)
				p.Array_size()
			}

		}
		{
			p.SetState(519)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
			{
				p.SetState(520)
				p.Field_type()
			}

		case SyslParserINDENT:
			{
				p.SetState(521)
				p.Inplace_tuple()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(524)
				p.Match(SyslParserQSTRING)
			}

		}

	}

	return localctx
}

// IInplace_tableContext is an interface to support dynamic dispatch.
type IInplace_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tableContext differentiates from other interfaces.
	IsInplace_tableContext()
}

type Inplace_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tableContext() *Inplace_tableContext {
	var p = new(Inplace_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table
	return p
}

func (*Inplace_tableContext) IsInplace_tableContext() {}

func NewInplace_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tableContext {
	var p = new(Inplace_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table

	return p
}

func (s *Inplace_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tableContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *Inplace_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table(s)
	}
}

func (s *Inplace_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table(s)
	}
}

func (p *SyslParser) Inplace_table() (localctx IInplace_tableContext) {
	localctx = NewInplace_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SyslParserRULE_inplace_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Table()
	}

	return localctx
}

// ITable_stmtsContext is an interface to support dynamic dispatch.
type ITable_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_stmtsContext differentiates from other interfaces.
	IsTable_stmtsContext()
}

type Table_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_stmtsContext() *Table_stmtsContext {
	var p = new(Table_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_stmts
	return p
}

func (*Table_stmtsContext) IsTable_stmtsContext() {}

func NewTable_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_stmtsContext {
	var p = new(Table_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_stmts

	return p
}

func (s *Table_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_stmtsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Table_stmtsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Table_stmtsContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Table_stmtsContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Table_stmtsContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Table_stmtsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *Table_stmtsContext) AllInplace_table() []IInplace_tableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem())
	var tst = make([]IInplace_tableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInplace_tableContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Inplace_table(i int) IInplace_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInplace_tableContext)
}

func (s *Table_stmtsContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *Table_stmtsContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *Table_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_stmts(s)
	}
}

func (s *Table_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_stmts(s)
	}
}

func (p *SyslParser) Table_stmts() (localctx ITable_stmtsContext) {
	localctx = NewTable_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SyslParserRULE_table_stmts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Match(SyslParserINDENT)
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserWHATEVER))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(532)
				p.Match(SyslParserSYSL_COMMENT)
			}

		case 2:
			{
				p.SetState(533)
				p.Field()
			}

		case 3:
			{
				p.SetState(534)
				p.Annotation()
			}

		case 4:
			{
				p.SetState(535)
				p.Inplace_table()
			}

		case 5:
			{
				p.SetState(536)
				p.Match(SyslParserWHATEVER)
			}

		}

		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(541)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_defContext is an interface to support dynamic dispatch.
type ITable_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_defContext differentiates from other interfaces.
	IsTable_defContext()
}

type Table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_defContext() *Table_defContext {
	var p = new(Table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_def
	return p
}

func (*Table_defContext) IsTable_defContext() {}

func NewTable_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_defContext {
	var p = new(Table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_def

	return p
}

func (s *Table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Table_defContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Table_defContext) Table_stmts() ITable_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_stmtsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_stmtsContext)
}

func (s *Table_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_def(s)
	}
}

func (s *Table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_def(s)
	}
}

func (p *SyslParser) Table_def() (localctx ITable_defContext) {
	localctx = NewTable_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SyslParserRULE_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(543)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(546)
		p.Match(SyslParserCOLON)
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(547)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(548)
			p.Table_stmts()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *TableContext) Table_def() ITable_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_defContext)
}

func (s *TableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *TableContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *TableContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *SyslParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SyslParserRULE_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(551)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(557)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTABLE || _la == SyslParserTYPE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(558)
		p.Name_str()
	}
	{
		p.SetState(559)
		p.Table_def()
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *UnionContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *UnionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *UnionContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *UnionContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *UnionContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *UnionContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *UnionContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *UnionContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *UnionContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *UnionContext) AllUser_defined_type() []IUser_defined_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem())
	var tst = make([]IUser_defined_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUser_defined_typeContext)
		}
	}

	return tst
}

func (s *UnionContext) User_defined_type(i int) IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *UnionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *SyslParser) Union() (localctx IUnionContext) {
	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SyslParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(561)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(567)
		p.Match(SyslParserUNION)
	}
	{
		p.SetState(568)
		p.Name_str()
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(569)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(572)
		p.Match(SyslParserCOLON)
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(573)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(574)
			p.Match(SyslParserINDENT)
		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserWHATEVER || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
			p.SetState(579)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserSYSL_COMMENT:
				{
					p.SetState(575)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(576)
					p.User_defined_type()
				}

			case SyslParserAT:
				{
					p.SetState(577)
					p.Annotation()
				}

			case SyslParserWHATEVER:
				{
					p.SetState(578)
					p.Match(SyslParserWHATEVER)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(581)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(583)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_nameContext is an interface to support dynamic dispatch.
type IPackage_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_nameContext differentiates from other interfaces.
	IsPackage_nameContext()
}

type Package_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_nameContext() *Package_nameContext {
	var p = new(Package_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_package_name
	return p
}

func (*Package_nameContext) IsPackage_nameContext() {}

func NewPackage_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_nameContext {
	var p = new(Package_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_package_name

	return p
}

func (s *Package_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_nameContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Package_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPackage_name(s)
	}
}

func (s *Package_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPackage_name(s)
	}
}

func (p *SyslParser) Package_name() (localctx IPackage_nameContext) {
	localctx = NewPackage_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SyslParserRULE_package_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Name_str()
	}

	return localctx
}

// ISub_packageContext is an interface to support dynamic dispatch.
type ISub_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSub_packageContext differentiates from other interfaces.
	IsSub_packageContext()
}

type Sub_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySub_packageContext() *Sub_packageContext {
	var p = new(Sub_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sub_package
	return p
}

func (*Sub_packageContext) IsSub_packageContext() {}

func NewSub_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sub_packageContext {
	var p = new(Sub_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sub_package

	return p
}

func (s *Sub_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Sub_packageContext) NAME_SEP() antlr.TerminalNode {
	return s.GetToken(SyslParserNAME_SEP, 0)
}

func (s *Sub_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Sub_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sub_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSub_package(s)
	}
}

func (s *Sub_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSub_package(s)
	}
}

func (p *SyslParser) Sub_package() (localctx ISub_packageContext) {
	localctx = NewSub_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SyslParserRULE_sub_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Match(SyslParserNAME_SEP)
	}
	{
		p.SetState(589)
		p.Package_name()
	}

	return localctx
}

// IApp_nameContext is an interface to support dynamic dispatch.
type IApp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApp_nameContext differentiates from other interfaces.
	IsApp_nameContext()
}

type App_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApp_nameContext() *App_nameContext {
	var p = new(App_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_name
	return p
}

func (*App_nameContext) IsApp_nameContext() {}

func NewApp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_nameContext {
	var p = new(App_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_name

	return p
}

func (s *App_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *App_nameContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *App_nameContext) AllSub_package() []ISub_packageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISub_packageContext)(nil)).Elem())
	var tst = make([]ISub_packageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISub_packageContext)
		}
	}

	return tst
}

func (s *App_nameContext) Sub_package(i int) ISub_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISub_packageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISub_packageContext)
}

func (s *App_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_name(s)
	}
}

func (s *App_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_name(s)
	}
}

func (p *SyslParser) App_name() (localctx IApp_nameContext) {
	localctx = NewApp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SyslParserRULE_app_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Package_name()
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(592)
				p.Sub_package()
			}

		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())
	}

	return localctx
}

// IName_with_attribsContext is an interface to support dynamic dispatch.
type IName_with_attribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_with_attribsContext differentiates from other interfaces.
	IsName_with_attribsContext()
}

type Name_with_attribsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_with_attribsContext() *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_with_attribs
	return p
}

func (*Name_with_attribsContext) IsName_with_attribsContext() {}

func NewName_with_attribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_with_attribs

	return p
}

func (s *Name_with_attribsContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_with_attribsContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Name_with_attribsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Name_with_attribsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Name_with_attribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_with_attribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_with_attribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_with_attribs(s)
	}
}

func (s *Name_with_attribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_with_attribs(s)
	}
}

func (p *SyslParser) Name_with_attribs() (localctx IName_with_attribsContext) {
	localctx = NewName_with_attribsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SyslParserRULE_name_with_attribs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.App_name()
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQSTRING {
		{
			p.SetState(599)
			p.Match(SyslParserQSTRING)
		}

	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(602)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IModel_nameContext is an interface to support dynamic dispatch.
type IModel_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_nameContext differentiates from other interfaces.
	IsModel_nameContext()
}

type Model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_nameContext() *Model_nameContext {
	var p = new(Model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_model_name
	return p
}

func (*Model_nameContext) IsModel_nameContext() {}

func NewModel_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_nameContext {
	var p = new(Model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_model_name

	return p
}

func (s *Model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_nameContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Model_nameContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModel_name(s)
	}
}

func (s *Model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModel_name(s)
	}
}

func (p *SyslParser) Model_name() (localctx IModel_nameContext) {
	localctx = NewModel_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SyslParserRULE_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(SyslParserName)
	}
	{
		p.SetState(606)
		p.Match(SyslParserCOLON)
	}

	return localctx
}

// IInplace_table_defContext is an interface to support dynamic dispatch.
type IInplace_table_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_table_defContext differentiates from other interfaces.
	IsInplace_table_defContext()
}

type Inplace_table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_table_defContext() *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table_def
	return p
}

func (*Inplace_table_defContext) IsInplace_table_defContext() {}

func NewInplace_table_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table_def

	return p
}

func (s *Inplace_table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Inplace_table_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_table_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_table_defContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Inplace_table_defContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Inplace_table_defContext) AllAttribs_or_modifiers() []IAttribs_or_modifiersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem())
	var tst = make([]IAttribs_or_modifiersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribs_or_modifiersContext)
		}
	}

	return tst
}

func (s *Inplace_table_defContext) Attribs_or_modifiers(i int) IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Inplace_table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table_def(s)
	}
}

func (s *Inplace_table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table_def(s)
	}
}

func (p *SyslParser) Inplace_table_def() (localctx IInplace_table_defContext) {
	localctx = NewInplace_table_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SyslParserRULE_inplace_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(609)
		p.Match(SyslParserINDENT)
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserName {
		{
			p.SetState(610)
			p.Match(SyslParserName)
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(611)
				p.Attribs_or_modifiers()
			}

		}

		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(618)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_refsContext is an interface to support dynamic dispatch.
type ITable_refsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_refsContext differentiates from other interfaces.
	IsTable_refsContext()
}

type Table_refsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refsContext() *Table_refsContext {
	var p = new(Table_refsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_refs
	return p
}

func (*Table_refsContext) IsTable_refsContext() {}

func NewTable_refsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refsContext {
	var p = new(Table_refsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_refs

	return p
}

func (s *Table_refsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Table_refsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *Table_refsContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *Table_refsContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *Table_refsContext) Inplace_table_def() IInplace_table_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_table_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_table_defContext)
}

func (s *Table_refsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_refs(s)
	}
}

func (s *Table_refsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_refs(s)
	}
}

func (p *SyslParser) Table_refs() (localctx ITable_refsContext) {
	localctx = NewTable_refsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SyslParserRULE_table_refs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(621)
		p.Match(SyslParserName)
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(622)
			p.Inplace_table_def()
		}

	}

	return localctx
}

// IFacadeContext is an interface to support dynamic dispatch.
type IFacadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFacadeContext differentiates from other interfaces.
	IsFacadeContext()
}

type FacadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFacadeContext() *FacadeContext {
	var p = new(FacadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_facade
	return p
}

func (*FacadeContext) IsFacadeContext() {}

func NewFacadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FacadeContext {
	var p = new(FacadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_facade

	return p
}

func (s *FacadeContext) GetParser() antlr.Parser { return s.parser }

func (s *FacadeContext) WRAP() antlr.TerminalNode {
	return s.GetToken(SyslParserWRAP, 0)
}

func (s *FacadeContext) Model_name() IModel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_nameContext)
}

func (s *FacadeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *FacadeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *FacadeContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *FacadeContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *FacadeContext) AllTable_refs() []ITable_refsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_refsContext)(nil)).Elem())
	var tst = make([]ITable_refsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_refsContext)
		}
	}

	return tst
}

func (s *FacadeContext) Table_refs(i int) ITable_refsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_refsContext)
}

func (s *FacadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FacadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FacadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFacade(s)
	}
}

func (s *FacadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFacade(s)
	}
}

func (p *SyslParser) Facade() (localctx IFacadeContext) {
	localctx = NewFacadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SyslParserRULE_facade)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(625)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(631)
		p.Match(SyslParserWRAP)
	}
	{
		p.SetState(632)
		p.Model_name()
	}
	{
		p.SetState(633)
		p.Match(SyslParserINDENT)
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		{
			p.SetState(634)
			p.Table_refs()
		}

		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(639)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IVar_in_curlyContext is an interface to support dynamic dispatch.
type IVar_in_curlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_in_curlyContext differentiates from other interfaces.
	IsVar_in_curlyContext()
}

type Var_in_curlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_in_curlyContext() *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_var_in_curly
	return p
}

func (*Var_in_curlyContext) IsVar_in_curlyContext() {}

func NewVar_in_curlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_var_in_curly

	return p
}

func (s *Var_in_curlyContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_in_curlyContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Var_in_curlyContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Var_in_curlyContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Var_in_curlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_in_curlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_in_curlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterVar_in_curly(s)
	}
}

func (s *Var_in_curlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitVar_in_curly(s)
	}
}

func (p *SyslParser) Var_in_curly() (localctx IVar_in_curlyContext) {
	localctx = NewVar_in_curlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SyslParserRULE_var_in_curly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(642)
		p.Match(SyslParserName)
	}
	{
		p.SetState(643)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IQuery_varContext is an interface to support dynamic dispatch.
type IQuery_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_varContext differentiates from other interfaces.
	IsQuery_varContext()
}

type Query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_varContext() *Query_varContext {
	var p = new(Query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_var
	return p
}

func (*Query_varContext) IsQuery_varContext() {}

func NewQuery_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_varContext {
	var p = new(Query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_var

	return p
}

func (s *Query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_varContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Query_varContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Query_varContext) Var_in_curly() IVar_in_curlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_in_curlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_in_curlyContext)
}

func (s *Query_varContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_var(s)
	}
}

func (s *Query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_var(s)
	}
}

func (p *SyslParser) Query_var() (localctx IQuery_varContext) {
	localctx = NewQuery_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SyslParserRULE_query_var)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Match(SyslParserName)
	}
	{
		p.SetState(646)
		p.Match(SyslParserEQ)
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(647)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(648)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(649)
			p.Var_in_curly()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(652)
			p.Match(SyslParserQN)
		}

	}

	return localctx
}

// IQuery_paramContext is an interface to support dynamic dispatch.
type IQuery_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_paramContext differentiates from other interfaces.
	IsQuery_paramContext()
}

type Query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_paramContext() *Query_paramContext {
	var p = new(Query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_param
	return p
}

func (*Query_paramContext) IsQuery_paramContext() {}

func NewQuery_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_paramContext {
	var p = new(Query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_param

	return p
}

func (s *Query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_paramContext) AllQuery_var() []IQuery_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuery_varContext)(nil)).Elem())
	var tst = make([]IQuery_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuery_varContext)
		}
	}

	return tst
}

func (s *Query_paramContext) Query_var(i int) IQuery_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuery_varContext)
}

func (s *Query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_param(s)
	}
}

func (s *Query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_param(s)
	}
}

func (p *SyslParser) Query_param() (localctx IQuery_paramContext) {
	localctx = NewQuery_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SyslParserRULE_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(656)
		p.Query_var()
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(657)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(658)
			p.Query_var()
		}

		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHttp_path_partContext is an interface to support dynamic dispatch.
type IHttp_path_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_partContext differentiates from other interfaces.
	IsHttp_path_partContext()
}

type Http_path_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_partContext() *Http_path_partContext {
	var p = new(Http_path_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_part
	return p
}

func (*Http_path_partContext) IsHttp_path_partContext() {}

func NewHttp_path_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_partContext {
	var p = new(Http_path_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_part

	return p
}

func (s *Http_path_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_partContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, 0)
}

func (s *Http_path_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_part(s)
	}
}

func (s *Http_path_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_part(s)
	}
}

func (p *SyslParser) Http_path_part() (localctx IHttp_path_partContext) {
	localctx = NewHttp_path_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SyslParserRULE_http_path_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(666)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(664)
			p.Name_str()
		}

	case SyslParserDIGITS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(665)
			p.Match(SyslParserDIGITS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_path_var_with_typeContext is an interface to support dynamic dispatch.
type IHttp_path_var_with_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_var_with_typeContext differentiates from other interfaces.
	IsHttp_path_var_with_typeContext()
}

type Http_path_var_with_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_var_with_typeContext() *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_var_with_type
	return p
}

func (*Http_path_var_with_typeContext) IsHttp_path_var_with_typeContext() {}

func NewHttp_path_var_with_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_var_with_type

	return p
}

func (s *Http_path_var_with_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_var_with_typeContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Http_path_var_with_typeContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_var_with_typeContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Http_path_var_with_typeContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Http_path_var_with_typeContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Http_path_var_with_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_var_with_typeContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *Http_path_var_with_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_var_with_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_var_with_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_var_with_type(s)
	}
}

func (s *Http_path_var_with_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_var_with_type(s)
	}
}

func (p *SyslParser) Http_path_var_with_type() (localctx IHttp_path_var_with_typeContext) {
	localctx = NewHttp_path_var_with_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SyslParserRULE_http_path_var_with_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(669)
		p.Http_path_part()
	}
	{
		p.SetState(670)
		p.Match(SyslParserLESS_COLON)
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(671)
			p.Match(SyslParserNativeDataTypes)
		}

	case 2:
		{
			p.SetState(672)
			p.Name_str()
		}

	case 3:
		{
			p.SetState(673)
			p.Reference()
		}

	}
	{
		p.SetState(676)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IHttp_path_staticContext is an interface to support dynamic dispatch.
type IHttp_path_staticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_staticContext differentiates from other interfaces.
	IsHttp_path_staticContext()
}

type Http_path_staticContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_staticContext() *Http_path_staticContext {
	var p = new(Http_path_staticContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_static
	return p
}

func (*Http_path_staticContext) IsHttp_path_staticContext() {}

func NewHttp_path_staticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_staticContext {
	var p = new(Http_path_staticContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_static

	return p
}

func (s *Http_path_staticContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_staticContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_staticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_staticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_staticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_static(s)
	}
}

func (s *Http_path_staticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_static(s)
	}
}

func (p *SyslParser) Http_path_static() (localctx IHttp_path_staticContext) {
	localctx = NewHttp_path_staticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SyslParserRULE_http_path_static)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Http_path_part()
	}

	return localctx
}

// IHttp_path_suffixContext is an interface to support dynamic dispatch.
type IHttp_path_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_suffixContext differentiates from other interfaces.
	IsHttp_path_suffixContext()
}

type Http_path_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_suffixContext() *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_suffix
	return p
}

func (*Http_path_suffixContext) IsHttp_path_suffixContext() {}

func NewHttp_path_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_suffix

	return p
}

func (s *Http_path_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_suffixContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_path_suffixContext) Http_path_static() IHttp_path_staticContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_staticContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_staticContext)
}

func (s *Http_path_suffixContext) Http_path_var_with_type() IHttp_path_var_with_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_var_with_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_var_with_typeContext)
}

func (s *Http_path_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_suffix(s)
	}
}

func (s *Http_path_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_suffix(s)
	}
}

func (p *SyslParser) Http_path_suffix() (localctx IHttp_path_suffixContext) {
	localctx = NewHttp_path_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SyslParserRULE_http_path_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(SyslParserFORWARD_SLASH)
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDIGITS, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(681)
			p.Http_path_static()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(682)
			p.Http_path_var_with_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_pathContext is an interface to support dynamic dispatch.
type IHttp_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_pathContext differentiates from other interfaces.
	IsHttp_pathContext()
}

type Http_pathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_pathContext() *Http_pathContext {
	var p = new(Http_pathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path
	return p
}

func (*Http_pathContext) IsHttp_pathContext() {}

func NewHttp_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_pathContext {
	var p = new(Http_pathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path

	return p
}

func (s *Http_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_pathContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_pathContext) AllHttp_path_suffix() []IHttp_path_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem())
	var tst = make([]IHttp_path_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHttp_path_suffixContext)
		}
	}

	return tst
}

func (s *Http_pathContext) Http_path_suffix(i int) IHttp_path_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_suffixContext)
}

func (s *Http_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path(s)
	}
}

func (s *Http_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path(s)
	}
}

func (p *SyslParser) Http_path() (localctx IHttp_pathContext) {
	localctx = NewHttp_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SyslParserRULE_http_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(685)
			p.Match(SyslParserFORWARD_SLASH)
		}

	case 2:
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
			{
				p.SetState(686)
				p.Http_path_suffix()
			}

			p.SetState(689)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndpoint_nameContext is an interface to support dynamic dispatch.
type IEndpoint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndpoint_nameContext differentiates from other interfaces.
	IsEndpoint_nameContext()
}

type Endpoint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpoint_nameContext() *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_endpoint_name
	return p
}

func (*Endpoint_nameContext) IsEndpoint_nameContext() {}

func NewEndpoint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_endpoint_name

	return p
}

func (s *Endpoint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Endpoint_nameContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Endpoint_nameContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Endpoint_nameContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Endpoint_nameContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Endpoint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Endpoint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Endpoint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEndpoint_name(s)
	}
}

func (s *Endpoint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEndpoint_name(s)
	}
}

func (p *SyslParser) Endpoint_name() (localctx IEndpoint_nameContext) {
	localctx = NewEndpoint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SyslParserRULE_endpoint_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Name_str()
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(694)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(695)
			p.Name_str()
		}

		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRet_stmtContext is an interface to support dynamic dispatch.
type IRet_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRet_stmtContext differentiates from other interfaces.
	IsRet_stmtContext()
}

type Ret_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRet_stmtContext() *Ret_stmtContext {
	var p = new(Ret_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ret_stmt
	return p
}

func (*Ret_stmtContext) IsRet_stmtContext() {}

func NewRet_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ret_stmtContext {
	var p = new(Ret_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ret_stmt

	return p
}

func (s *Ret_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Ret_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SyslParserRETURN, 0)
}

func (s *Ret_stmtContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Ret_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ret_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ret_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRet_stmt(s)
	}
}

func (s *Ret_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRet_stmt(s)
	}
}

func (p *SyslParser) Ret_stmt() (localctx IRet_stmtContext) {
	localctx = NewRet_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SyslParserRULE_ret_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.Match(SyslParserRETURN)
	}
	{
		p.SetState(702)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (p *SyslParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SyslParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.App_name()
	}

	return localctx
}

// ITarget_endpointContext is an interface to support dynamic dispatch.
type ITarget_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTarget_endpointContext differentiates from other interfaces.
	IsTarget_endpointContext()
}

type Target_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTarget_endpointContext() *Target_endpointContext {
	var p = new(Target_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target_endpoint
	return p
}

func (*Target_endpointContext) IsTarget_endpointContext() {}

func NewTarget_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Target_endpointContext {
	var p = new(Target_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target_endpoint

	return p
}

func (s *Target_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Target_endpointContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Target_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Target_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget_endpoint(s)
	}
}

func (s *Target_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget_endpoint(s)
	}
}

func (p *SyslParser) Target_endpoint() (localctx ITarget_endpointContext) {
	localctx = NewTarget_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SyslParserRULE_target_endpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Name_str()
	}

	return localctx
}

// ICall_argContext is an interface to support dynamic dispatch.
type ICall_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argContext differentiates from other interfaces.
	IsCall_argContext()
}

type Call_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argContext() *Call_argContext {
	var p = new(Call_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_arg
	return p
}

func (*Call_argContext) IsCall_argContext() {}

func NewCall_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argContext {
	var p = new(Call_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_arg

	return p
}

func (s *Call_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *Call_argContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *Call_argContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Call_argContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Call_argContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Call_argContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Call_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_arg(s)
	}
}

func (s *Call_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_arg(s)
	}
}

func (p *SyslParser) Call_arg() (localctx ICall_argContext) {
	localctx = NewCall_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SyslParserRULE_call_arg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0) || _la == SyslParserE_Name {
			p.SetState(710)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserQSTRING:
				{
					p.SetState(708)
					p.Match(SyslParserQSTRING)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(709)
					p.Name_str()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(714)
			p.Name_str()
		}
		{
			p.SetState(715)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(716)
				p.Name_str()
			}

		case SyslParserNativeDataTypes:
			{
				p.SetState(717)
				p.Match(SyslParserNativeDataTypes)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICall_argsContext is an interface to support dynamic dispatch.
type ICall_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argsContext differentiates from other interfaces.
	IsCall_argsContext()
}

type Call_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argsContext() *Call_argsContext {
	var p = new(Call_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_args
	return p
}

func (*Call_argsContext) IsCall_argsContext() {}

func NewCall_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argsContext {
	var p = new(Call_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_args

	return p
}

func (s *Call_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Call_argsContext) AllCall_arg() []ICall_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICall_argContext)(nil)).Elem())
	var tst = make([]ICall_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICall_argContext)
		}
	}

	return tst
}

func (s *Call_argsContext) Call_arg(i int) ICall_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICall_argContext)
}

func (s *Call_argsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Call_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Call_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Call_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_args(s)
	}
}

func (s *Call_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_args(s)
	}
}

func (p *SyslParser) Call_args() (localctx ICall_argsContext) {
	localctx = NewCall_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SyslParserRULE_call_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(723)
		p.Call_arg()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(724)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(725)
			p.Call_arg()
		}

		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(731)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_stmt
	return p
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Call_stmtContext) DOT_ARROW() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT_ARROW, 0)
}

func (s *Call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Call_stmtContext) Call_args() ICall_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_argsContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *SyslParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SyslParserRULE_call_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(737)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDOT_ARROW:
		{
			p.SetState(733)
			p.Match(SyslParserDOT_ARROW)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(734)
			p.Target()
		}
		{
			p.SetState(735)
			p.Match(SyslParserARROW_LEFT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(739)
		p.Target_endpoint()
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(740)
			p.Call_args()
		}

	}

	return localctx
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SyslParserIF, 0)
}

func (s *If_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *If_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *SyslParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SyslParserRULE_if_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(SyslParserIF)
	}
	{
		p.SetState(744)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(745)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(746)
		p.Match(SyslParserINDENT)
	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(747)
			p.Statements()
		}

		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(753)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IElse_stmtContext is an interface to support dynamic dispatch.
type IElse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_stmtContext differentiates from other interfaces.
	IsElse_stmtContext()
}

type Else_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_stmtContext() *Else_stmtContext {
	var p = new(Else_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_stmt
	return p
}

func (*Else_stmtContext) IsElse_stmtContext() {}

func NewElse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_stmtContext {
	var p = new(Else_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_stmt

	return p
}

func (s *Else_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserELSE, 0)
}

func (s *Else_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Else_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Else_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Else_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *Else_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Else_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Else_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_stmt(s)
	}
}

func (s *Else_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_stmt(s)
	}
}

func (p *SyslParser) Else_stmt() (localctx IElse_stmtContext) {
	localctx = NewElse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SyslParserRULE_else_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(SyslParserELSE)
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserPREDICATE_VALUE {
		{
			p.SetState(756)
			p.Match(SyslParserPREDICATE_VALUE)
		}

	}
	{
		p.SetState(759)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(760)
		p.Match(SyslParserINDENT)
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(761)
			p.Statements()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IIf_elseContext is an interface to support dynamic dispatch.
type IIf_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elseContext differentiates from other interfaces.
	IsIf_elseContext()
}

type If_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elseContext() *If_elseContext {
	var p = new(If_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_else
	return p
}

func (*If_elseContext) IsIf_elseContext() {}

func NewIf_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elseContext {
	var p = new(If_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_else

	return p
}

func (s *If_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elseContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *If_elseContext) AllElse_stmt() []IElse_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem())
	var tst = make([]IElse_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElse_stmtContext)
		}
	}

	return tst
}

func (s *If_elseContext) Else_stmt(i int) IElse_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElse_stmtContext)
}

func (s *If_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_else(s)
	}
}

func (s *If_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_else(s)
	}
}

func (p *SyslParser) If_else() (localctx IIf_elseContext) {
	localctx = NewIf_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SyslParserRULE_if_else)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.If_stmt()
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserELSE {
		{
			p.SetState(770)
			p.Else_stmt()
		}

		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *For_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *For_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *For_stmtContext) ALT() antlr.TerminalNode {
	return s.GetToken(SyslParserALT, 0)
}

func (s *For_stmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SyslParserUNTIL, 0)
}

func (s *For_stmtContext) FOR_EACH() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR_EACH, 0)
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR, 0)
}

func (s *For_stmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SyslParserLOOP, 0)
}

func (s *For_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SyslParserWHILE, 0)
}

func (s *For_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *SyslParser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SyslParserRULE_for_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(776)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(777)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(778)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(779)
		p.Match(SyslParserINDENT)
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(780)
			p.Statements()
		}

		p.SetState(785)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(786)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IHttp_method_commentContext is an interface to support dynamic dispatch.
type IHttp_method_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_method_commentContext differentiates from other interfaces.
	IsHttp_method_commentContext()
}

type Http_method_commentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_method_commentContext() *Http_method_commentContext {
	var p = new(Http_method_commentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_method_comment
	return p
}

func (*Http_method_commentContext) IsHttp_method_commentContext() {}

func NewHttp_method_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_method_commentContext {
	var p = new(Http_method_commentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_method_comment

	return p
}

func (s *Http_method_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_method_commentContext) SYSL_COMMENT() antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, 0)
}

func (s *Http_method_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_method_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_method_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_method_comment(s)
	}
}

func (s *Http_method_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_method_comment(s)
	}
}

func (p *SyslParser) Http_method_comment() (localctx IHttp_method_commentContext) {
	localctx = NewHttp_method_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SyslParserRULE_http_method_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)
		p.Match(SyslParserSYSL_COMMENT)
	}

	return localctx
}

// IGroup_stmtContext is an interface to support dynamic dispatch.
type IGroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_stmtContext differentiates from other interfaces.
	IsGroup_stmtContext()
}

type Group_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_stmtContext() *Group_stmtContext {
	var p = new(Group_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_group_stmt
	return p
}

func (*Group_stmtContext) IsGroup_stmtContext() {}

func NewGroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_stmtContext {
	var p = new(Group_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_group_stmt

	return p
}

func (s *Group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Group_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Group_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Group_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Group_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Group_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterGroup_stmt(s)
	}
}

func (s *Group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitGroup_stmt(s)
	}
}

func (p *SyslParser) Group_stmt() (localctx IGroup_stmtContext) {
	localctx = NewGroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SyslParserRULE_group_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Name_str()
	}
	{
		p.SetState(791)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(792)
		p.Match(SyslParserINDENT)
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(793)
			p.Statements()
		}

		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(798)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_case_labelContext is an interface to support dynamic dispatch.
type IOne_of_case_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_case_labelContext differentiates from other interfaces.
	IsOne_of_case_labelContext()
}

type One_of_case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_case_labelContext() *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_case_label
	return p
}

func (*One_of_case_labelContext) IsOne_of_case_labelContext() {}

func NewOne_of_case_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_case_label

	return p
}

func (s *One_of_case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_case_labelContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *One_of_case_labelContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *One_of_case_labelContext) AllTEXT_LINE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserTEXT_LINE)
}

func (s *One_of_case_labelContext) TEXT_LINE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, i)
}

func (s *One_of_case_labelContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *One_of_case_labelContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *One_of_case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_case_label(s)
	}
}

func (s *One_of_case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_case_label(s)
	}
}

func (p *SyslParser) One_of_case_label() (localctx IOne_of_case_labelContext) {
	localctx = NewOne_of_case_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SyslParserRULE_one_of_case_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0) {
		p.SetState(800)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOne_of_casesContext is an interface to support dynamic dispatch.
type IOne_of_casesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_casesContext differentiates from other interfaces.
	IsOne_of_casesContext()
}

type One_of_casesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_casesContext() *One_of_casesContext {
	var p = new(One_of_casesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_cases
	return p
}

func (*One_of_casesContext) IsOne_of_casesContext() {}

func NewOne_of_casesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_casesContext {
	var p = new(One_of_casesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_cases

	return p
}

func (s *One_of_casesContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_casesContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_casesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_casesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_casesContext) One_of_case_label() IOne_of_case_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_case_labelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_case_labelContext)
}

func (s *One_of_casesContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *One_of_casesContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *One_of_casesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_casesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_casesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_cases(s)
	}
}

func (s *One_of_casesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_cases(s)
	}
}

func (p *SyslParser) One_of_cases() (localctx IOne_of_casesContext) {
	localctx = NewOne_of_casesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SyslParserRULE_one_of_cases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SyslParserQSTRING-58))|(1<<(SyslParserTEXT_LINE-58))|(1<<(SyslParserName-58)))) != 0 {
		{
			p.SetState(805)
			p.One_of_case_label()
		}

	}
	{
		p.SetState(808)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(809)
		p.Match(SyslParserINDENT)
	}
	p.SetState(811)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(810)
			p.Statements()
		}

		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(815)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_stmtContext is an interface to support dynamic dispatch.
type IOne_of_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_stmtContext differentiates from other interfaces.
	IsOne_of_stmtContext()
}

type One_of_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_stmtContext() *One_of_stmtContext {
	var p = new(One_of_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_stmt
	return p
}

func (*One_of_stmtContext) IsOne_of_stmtContext() {}

func NewOne_of_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_stmtContext {
	var p = new(One_of_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_stmt

	return p
}

func (s *One_of_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_stmtContext) ONE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserONE_OF, 0)
}

func (s *One_of_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_stmtContext) AllOne_of_cases() []IOne_of_casesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem())
	var tst = make([]IOne_of_casesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOne_of_casesContext)
		}
	}

	return tst
}

func (s *One_of_stmtContext) One_of_cases(i int) IOne_of_casesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOne_of_casesContext)
}

func (s *One_of_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_stmt(s)
	}
}

func (s *One_of_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_stmt(s)
	}
}

func (p *SyslParser) One_of_stmt() (localctx IOne_of_stmtContext) {
	localctx = NewOne_of_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SyslParserRULE_one_of_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Match(SyslParserONE_OF)
	}
	{
		p.SetState(818)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(819)
		p.Match(SyslParserINDENT)
	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SyslParserCOLON-41))|(1<<(SyslParserQSTRING-41))|(1<<(SyslParserTEXT_LINE-41))|(1<<(SyslParserName-41)))) != 0) {
		{
			p.SetState(820)
			p.One_of_cases()
		}

		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(825)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IText_stmtContext is an interface to support dynamic dispatch.
type IText_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_stmtContext differentiates from other interfaces.
	IsText_stmtContext()
}

type Text_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stmtContext() *Text_stmtContext {
	var p = new(Text_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_text_stmt
	return p
}

func (*Text_stmtContext) IsText_stmtContext() {}

func NewText_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stmtContext {
	var p = new(Text_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_text_stmt

	return p
}

func (s *Text_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stmtContext) Doc_string() IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Text_stmtContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Text_stmtContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Text_stmtContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Text_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Text_stmtContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Text_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterText_stmt(s)
	}
}

func (s *Text_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitText_stmt(s)
	}
}

func (p *SyslParser) Text_stmt() (localctx IText_stmtContext) {
	localctx = NewText_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SyslParserRULE_text_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(835)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserPIPE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(827)
			p.Doc_string()
		}

	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(828)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(829)
			p.App_name()
		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserARROW_RIGHT {
			{
				p.SetState(830)
				p.Match(SyslParserARROW_RIGHT)
			}
			{
				p.SetState(831)
				p.Name_str()
			}

		}

	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(834)
			p.Match(SyslParserWHATEVER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinContext is an interface to support dynamic dispatch.
type IMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinContext differentiates from other interfaces.
	IsMixinContext()
}

type MixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinContext() *MixinContext {
	var p = new(MixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_mixin
	return p
}

func (*MixinContext) IsMixinContext() {}

func NewMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinContext {
	var p = new(MixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_mixin

	return p
}

func (s *MixinContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinContext) MIXIN() antlr.TerminalNode {
	return s.GetToken(SyslParserMIXIN, 0)
}

func (s *MixinContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *MixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMixin(s)
	}
}

func (s *MixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMixin(s)
	}
}

func (p *SyslParser) Mixin() (localctx IMixinContext) {
	localctx = NewMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SyslParserRULE_mixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)
		p.Match(SyslParserMIXIN)
	}
	{
		p.SetState(838)
		p.App_name()
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ParamContext) Field() IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *SyslParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SyslParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(840)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(841)
			p.Field()
		}

	}

	return localctx
}

// IParam_listContext is an interface to support dynamic dispatch.
type IParam_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_listContext differentiates from other interfaces.
	IsParam_listContext()
}

type Param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_listContext() *Param_listContext {
	var p = new(Param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param_list
	return p
}

func (*Param_listContext) IsParam_listContext() {}

func NewParam_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_listContext {
	var p = new(Param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param_list

	return p
}

func (s *Param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_listContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *Param_listContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *Param_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Param_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam_list(s)
	}
}

func (s *Param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam_list(s)
	}
}

func (p *SyslParser) Param_list() (localctx IParam_listContext) {
	localctx = NewParam_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SyslParserRULE_param_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Param()
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(845)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(846)
			p.Param()
		}

		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamsContext is an interface to support dynamic dispatch.
type IParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamsContext differentiates from other interfaces.
	IsParamsContext()
}

type ParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamsContext() *ParamsContext {
	var p = new(ParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_params
	return p
}

func (*ParamsContext) IsParamsContext() {}

func NewParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamsContext {
	var p = new(ParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_params

	return p
}

func (s *ParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ParamsContext) Param_list() IParam_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_listContext)
}

func (s *ParamsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParams(s)
	}
}

func (s *ParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParams(s)
	}
}

func (p *SyslParser) Params() (localctx IParamsContext) {
	localctx = NewParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SyslParserRULE_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(853)
		p.Param_list()
	}
	{
		p.SetState(854)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) If_else() IIf_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elseContext)
}

func (s *StatementsContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *StatementsContext) Ret_stmt() IRet_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRet_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRet_stmtContext)
}

func (s *StatementsContext) Call_stmt() ICall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StatementsContext) One_of_stmt() IOne_of_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_stmtContext)
}

func (s *StatementsContext) Http_method_comment() IHttp_method_commentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_method_commentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_method_commentContext)
}

func (s *StatementsContext) Group_stmt() IGroup_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_stmtContext)
}

func (s *StatementsContext) Text_stmt() IText_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_stmtContext)
}

func (s *StatementsContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SyslParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SyslParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(856)
			p.If_else()
		}

	case 2:
		{
			p.SetState(857)
			p.For_stmt()
		}

	case 3:
		{
			p.SetState(858)
			p.Ret_stmt()
		}

	case 4:
		{
			p.SetState(859)
			p.Call_stmt()
		}

	case 5:
		{
			p.SetState(860)
			p.One_of_stmt()
		}

	case 6:
		{
			p.SetState(861)
			p.Http_method_comment()
		}

	case 7:
		{
			p.SetState(862)
			p.Group_stmt()
		}

	case 8:
		{
			p.SetState(863)
			p.Text_stmt()
		}

	case 9:
		{
			p.SetState(864)
			p.Annotation()
		}

	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(867)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IMethod_defContext is an interface to support dynamic dispatch.
type IMethod_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_defContext differentiates from other interfaces.
	IsMethod_defContext()
}

type Method_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_defContext() *Method_defContext {
	var p = new(Method_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_method_def
	return p
}

func (*Method_defContext) IsMethod_defContext() {}

func NewMethod_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_defContext {
	var p = new(Method_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_method_def

	return p
}

func (s *Method_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_defContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Method_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Method_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Method_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Method_defContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Method_defContext) Query_param() IQuery_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_paramContext)
}

func (s *Method_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Method_defContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Method_defContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Method_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMethod_def(s)
	}
}

func (s *Method_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMethod_def(s)
	}
}

func (p *SyslParser) Method_def() (localctx IMethod_defContext) {
	localctx = NewMethod_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SyslParserRULE_method_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(SyslParserHTTP_VERBS)
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(871)
			p.Params()
		}

	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(874)
			p.Query_param()
		}

	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(877)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(880)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(881)
		p.Match(SyslParserINDENT)
	}
	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(882)
			p.Statements()
		}

		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(887)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IShortcutContext is an interface to support dynamic dispatch.
type IShortcutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortcutContext differentiates from other interfaces.
	IsShortcutContext()
}

type ShortcutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortcutContext() *ShortcutContext {
	var p = new(ShortcutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_shortcut
	return p
}

func (*ShortcutContext) IsShortcutContext() {}

func NewShortcutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortcutContext {
	var p = new(ShortcutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_shortcut

	return p
}

func (s *ShortcutContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortcutContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *ShortcutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortcutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortcutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterShortcut(s)
	}
}

func (s *ShortcutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitShortcut(s)
	}
}

func (p *SyslParser) Shortcut() (localctx IShortcutContext) {
	localctx = NewShortcutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SyslParserRULE_shortcut)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.Match(SyslParserWHATEVER)
	}

	return localctx
}

// ISimple_endpointContext is an interface to support dynamic dispatch.
type ISimple_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_endpointContext differentiates from other interfaces.
	IsSimple_endpointContext()
}

type Simple_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_endpointContext() *Simple_endpointContext {
	var p = new(Simple_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_simple_endpoint
	return p
}

func (*Simple_endpointContext) IsSimple_endpointContext() {}

func NewSimple_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_endpointContext {
	var p = new(Simple_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_simple_endpoint

	return p
}

func (s *Simple_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_endpointContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Simple_endpointContext) Endpoint_name() IEndpoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndpoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndpoint_nameContext)
}

func (s *Simple_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Simple_endpointContext) Shortcut() IShortcutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShortcutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShortcutContext)
}

func (s *Simple_endpointContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Simple_endpointContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Simple_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Simple_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Simple_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Simple_endpointContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Simple_endpointContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Simple_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSimple_endpoint(s)
	}
}

func (s *Simple_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSimple_endpoint(s)
	}
}

func (p *SyslParser) Simple_endpoint() (localctx ISimple_endpointContext) {
	localctx = NewSimple_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SyslParserRULE_simple_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(914)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(891)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.Endpoint_name()
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(893)
				p.Match(SyslParserQSTRING)
			}

		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(896)
				p.Params()
			}

		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(899)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(902)
			p.Match(SyslParserCOLON)
		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserWHATEVER:
			{
				p.SetState(903)
				p.Shortcut()
			}

		case SyslParserINDENT:
			{
				p.SetState(904)
				p.Match(SyslParserINDENT)
			}
			p.SetState(906)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
				{
					p.SetState(905)
					p.Statements()
				}

				p.SetState(908)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(910)
				p.Match(SyslParserDEDENT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRest_endpointContext is an interface to support dynamic dispatch.
type IRest_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRest_endpointContext differentiates from other interfaces.
	IsRest_endpointContext()
}

type Rest_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRest_endpointContext() *Rest_endpointContext {
	var p = new(Rest_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rest_endpoint
	return p
}

func (*Rest_endpointContext) IsRest_endpointContext() {}

func NewRest_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rest_endpointContext {
	var p = new(Rest_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rest_endpoint

	return p
}

func (s *Rest_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Rest_endpointContext) Http_path() IHttp_pathContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_pathContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_pathContext)
}

func (s *Rest_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Rest_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Rest_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Rest_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Rest_endpointContext) AllMethod_def() []IMethod_defContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_defContext)(nil)).Elem())
	var tst = make([]IMethod_defContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_defContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Method_def(i int) IMethod_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_defContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_defContext)
}

func (s *Rest_endpointContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *Rest_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rest_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rest_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRest_endpoint(s)
	}
}

func (s *Rest_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRest_endpoint(s)
	}
}

func (p *SyslParser) Rest_endpoint() (localctx IRest_endpointContext) {
	localctx = NewRest_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SyslParserRULE_rest_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.Http_path()
	}
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(917)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(920)
		p.Match(SyslParserCOLON)
	}

	{
		p.SetState(921)
		p.Match(SyslParserINDENT)
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserFORWARD_SLASH {
		p.SetState(924)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserHTTP_VERBS:
			{
				p.SetState(922)
				p.Method_def()
			}

		case SyslParserFORWARD_SLASH:
			{
				p.SetState(923)
				p.Rest_endpoint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(928)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ICollector_query_varContext is an interface to support dynamic dispatch.
type ICollector_query_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_varContext differentiates from other interfaces.
	IsCollector_query_varContext()
}

type Collector_query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_varContext() *Collector_query_varContext {
	var p = new(Collector_query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_var
	return p
}

func (*Collector_query_varContext) IsCollector_query_varContext() {}

func NewCollector_query_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_varContext {
	var p = new(Collector_query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_var

	return p
}

func (s *Collector_query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_varContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Collector_query_varContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Collector_query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Collector_query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_var(s)
	}
}

func (s *Collector_query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_var(s)
	}
}

func (p *SyslParser) Collector_query_var() (localctx ICollector_query_varContext) {
	localctx = NewCollector_query_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SyslParserRULE_collector_query_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Name_str()
	}
	{
		p.SetState(931)
		p.Match(SyslParserEQ)
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(932)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(933)
			p.Name_str()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_query_paramContext is an interface to support dynamic dispatch.
type ICollector_query_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_paramContext differentiates from other interfaces.
	IsCollector_query_paramContext()
}

type Collector_query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_paramContext() *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_param
	return p
}

func (*Collector_query_paramContext) IsCollector_query_paramContext() {}

func NewCollector_query_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_param

	return p
}

func (s *Collector_query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Collector_query_paramContext) AllCollector_query_var() []ICollector_query_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem())
	var tst = make([]ICollector_query_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_query_varContext)
		}
	}

	return tst
}

func (s *Collector_query_paramContext) Collector_query_var(i int) ICollector_query_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_varContext)
}

func (s *Collector_query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Collector_query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Collector_query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_param(s)
	}
}

func (s *Collector_query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_param(s)
	}
}

func (p *SyslParser) Collector_query_param() (localctx ICollector_query_paramContext) {
	localctx = NewCollector_query_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SyslParserRULE_collector_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(937)
		p.Collector_query_var()
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(938)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(939)
			p.Collector_query_var()
		}

		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICollector_call_stmtContext is an interface to support dynamic dispatch.
type ICollector_call_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_call_stmtContext differentiates from other interfaces.
	IsCollector_call_stmtContext()
}

type Collector_call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_call_stmtContext() *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_call_stmt
	return p
}

func (*Collector_call_stmtContext) IsCollector_call_stmtContext() {}

func NewCollector_call_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_call_stmt

	return p
}

func (s *Collector_call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Collector_call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Collector_call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_call_stmt(s)
	}
}

func (s *Collector_call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_call_stmt(s)
	}
}

func (p *SyslParser) Collector_call_stmt() (localctx ICollector_call_stmtContext) {
	localctx = NewCollector_call_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SyslParserRULE_collector_call_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.Target()
	}
	{
		p.SetState(946)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(947)
		p.Target_endpoint()
	}

	return localctx
}

// ICollector_http_stmt_partContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_partContext differentiates from other interfaces.
	IsCollector_http_stmt_partContext()
}

type Collector_http_stmt_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_partContext() *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part
	return p
}

func (*Collector_http_stmt_partContext) IsCollector_http_stmt_partContext() {}

func NewCollector_http_stmt_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part

	return p
}

func (s *Collector_http_stmt_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_http_stmt_partContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Collector_http_stmt_partContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Collector_http_stmt_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_part(s)
	}
}

func (s *Collector_http_stmt_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_part(s)
	}
}

func (p *SyslParser) Collector_http_stmt_part() (localctx ICollector_http_stmt_partContext) {
	localctx = NewCollector_http_stmt_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SyslParserRULE_collector_http_stmt_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(954)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(949)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(950)
			p.Match(SyslParserCURLY_OPEN)
		}
		{
			p.SetState(951)
			p.Name_str()
		}
		{
			p.SetState(952)
			p.Match(SyslParserCURLY_CLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_http_stmt_suffixContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_suffixContext differentiates from other interfaces.
	IsCollector_http_stmt_suffixContext()
}

type Collector_http_stmt_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_suffixContext() *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix
	return p
}

func (*Collector_http_stmt_suffixContext) IsCollector_http_stmt_suffixContext() {}

func NewCollector_http_stmt_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix

	return p
}

func (s *Collector_http_stmt_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_suffixContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Collector_http_stmt_suffixContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Collector_http_stmt_suffixContext) AllCollector_http_stmt_part() []ICollector_http_stmt_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem())
	var tst = make([]ICollector_http_stmt_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_http_stmt_partContext)
		}
	}

	return tst
}

func (s *Collector_http_stmt_suffixContext) Collector_http_stmt_part(i int) ICollector_http_stmt_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_partContext)
}

func (s *Collector_http_stmt_suffixContext) Collector_query_param() ICollector_query_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_paramContext)
}

func (s *Collector_http_stmt_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_suffix(s)
	}
}

func (s *Collector_http_stmt_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_suffix(s)
	}
}

func (p *SyslParser) Collector_http_stmt_suffix() (localctx ICollector_http_stmt_suffixContext) {
	localctx = NewCollector_http_stmt_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SyslParserRULE_collector_http_stmt_suffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(956)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(957)
			p.Collector_http_stmt_part()
		}

		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(962)
			p.Collector_query_param()
		}

	}

	return localctx
}

// ICollector_http_stmtContext is an interface to support dynamic dispatch.
type ICollector_http_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmtContext differentiates from other interfaces.
	IsCollector_http_stmtContext()
}

type Collector_http_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmtContext() *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt
	return p
}

func (*Collector_http_stmtContext) IsCollector_http_stmtContext() {}

func NewCollector_http_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt

	return p
}

func (s *Collector_http_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmtContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Collector_http_stmtContext) Collector_http_stmt_suffix() ICollector_http_stmt_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_suffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_suffixContext)
}

func (s *Collector_http_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt(s)
	}
}

func (s *Collector_http_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt(s)
	}
}

func (p *SyslParser) Collector_http_stmt() (localctx ICollector_http_stmtContext) {
	localctx = NewCollector_http_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SyslParserRULE_collector_http_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Match(SyslParserHTTP_VERBS)
	}
	{
		p.SetState(966)
		p.Collector_http_stmt_suffix()
	}

	return localctx
}

// IPublisherContext is an interface to support dynamic dispatch.
type IPublisherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublisherContext differentiates from other interfaces.
	IsPublisherContext()
}

type PublisherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublisherContext() *PublisherContext {
	var p = new(PublisherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_publisher
	return p
}

func (*PublisherContext) IsPublisherContext() {}

func NewPublisherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PublisherContext {
	var p = new(PublisherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_publisher

	return p
}

func (s *PublisherContext) GetParser() antlr.Parser { return s.parser }

func (s *PublisherContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *PublisherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PublisherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PublisherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPublisher(s)
	}
}

func (s *PublisherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPublisher(s)
	}
}

func (p *SyslParser) Publisher() (localctx IPublisherContext) {
	localctx = NewPublisherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SyslParserRULE_publisher)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(968)
		p.App_name()
	}

	return localctx
}

// ISubscriberContext is an interface to support dynamic dispatch.
type ISubscriberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriberContext differentiates from other interfaces.
	IsSubscriberContext()
}

type SubscriberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriberContext() *SubscriberContext {
	var p = new(SubscriberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscriber
	return p
}

func (*SubscriberContext) IsSubscriberContext() {}

func NewSubscriberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriberContext {
	var p = new(SubscriberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscriber

	return p
}

func (s *SubscriberContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriberContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscriberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscriber(s)
	}
}

func (s *SubscriberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscriber(s)
	}
}

func (p *SyslParser) Subscriber() (localctx ISubscriberContext) {
	localctx = NewSubscriberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SyslParserRULE_subscriber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.App_name()
	}

	return localctx
}

// ICollector_pubsub_callContext is an interface to support dynamic dispatch.
type ICollector_pubsub_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_pubsub_callContext differentiates from other interfaces.
	IsCollector_pubsub_callContext()
}

type Collector_pubsub_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_pubsub_callContext() *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_pubsub_call
	return p
}

func (*Collector_pubsub_callContext) IsCollector_pubsub_callContext() {}

func NewCollector_pubsub_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_pubsub_call

	return p
}

func (s *Collector_pubsub_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_pubsub_callContext) Subscriber() ISubscriberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriberContext)
}

func (s *Collector_pubsub_callContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_pubsub_callContext) Publisher() IPublisherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublisherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublisherContext)
}

func (s *Collector_pubsub_callContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Collector_pubsub_callContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_pubsub_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_pubsub_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_pubsub_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_pubsub_call(s)
	}
}

func (s *Collector_pubsub_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_pubsub_call(s)
	}
}

func (p *SyslParser) Collector_pubsub_call() (localctx ICollector_pubsub_callContext) {
	localctx = NewCollector_pubsub_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SyslParserRULE_collector_pubsub_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(972)
		p.Subscriber()
	}
	{
		p.SetState(973)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(974)
		p.Publisher()
	}
	{
		p.SetState(975)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(976)
		p.Name_str()
	}

	return localctx
}

// ICollector_action_stmtContext is an interface to support dynamic dispatch.
type ICollector_action_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_action_stmtContext differentiates from other interfaces.
	IsCollector_action_stmtContext()
}

type Collector_action_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_action_stmtContext() *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_action_stmt
	return p
}

func (*Collector_action_stmtContext) IsCollector_action_stmtContext() {}

func NewCollector_action_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_action_stmt

	return p
}

func (s *Collector_action_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_action_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_action_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_action_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_action_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_action_stmt(s)
	}
}

func (s *Collector_action_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_action_stmt(s)
	}
}

func (p *SyslParser) Collector_action_stmt() (localctx ICollector_action_stmtContext) {
	localctx = NewCollector_action_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SyslParserRULE_collector_action_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(978)
		p.Name_str()
	}

	return localctx
}

// ICollector_stmtsContext is an interface to support dynamic dispatch.
type ICollector_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_stmtsContext differentiates from other interfaces.
	IsCollector_stmtsContext()
}

type Collector_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_stmtsContext() *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_stmts
	return p
}

func (*Collector_stmtsContext) IsCollector_stmtsContext() {}

func NewCollector_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_stmts

	return p
}

func (s *Collector_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_stmtsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Collector_stmtsContext) Collector_action_stmt() ICollector_action_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_action_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_action_stmtContext)
}

func (s *Collector_stmtsContext) Collector_call_stmt() ICollector_call_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_call_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_call_stmtContext)
}

func (s *Collector_stmtsContext) Collector_http_stmt() ICollector_http_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmtContext)
}

func (s *Collector_stmtsContext) Collector_pubsub_call() ICollector_pubsub_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_pubsub_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_pubsub_callContext)
}

func (s *Collector_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_stmts(s)
	}
}

func (s *Collector_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_stmts(s)
	}
}

func (p *SyslParser) Collector_stmts() (localctx ICollector_stmtsContext) {
	localctx = NewCollector_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SyslParserRULE_collector_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(980)
			p.Collector_action_stmt()
		}

	case 2:
		{
			p.SetState(981)
			p.Collector_call_stmt()
		}

	case 3:
		{
			p.SetState(982)
			p.Collector_http_stmt()
		}

	case 4:
		{
			p.SetState(983)
			p.Collector_pubsub_call()
		}

	}
	{
		p.SetState(986)
		p.Attribs_or_modifiers()
	}

	return localctx
}

// ICollectorContext is an interface to support dynamic dispatch.
type ICollectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectorContext differentiates from other interfaces.
	IsCollectorContext()
}

type CollectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectorContext() *CollectorContext {
	var p = new(CollectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector
	return p
}

func (*CollectorContext) IsCollectorContext() {}

func NewCollectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectorContext {
	var p = new(CollectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector

	return p
}

func (s *CollectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectorContext) COLLECTOR() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLLECTOR, 0)
}

func (s *CollectorContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *CollectorContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *CollectorContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *CollectorContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *CollectorContext) AllCollector_stmts() []ICollector_stmtsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem())
	var tst = make([]ICollector_stmtsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_stmtsContext)
		}
	}

	return tst
}

func (s *CollectorContext) Collector_stmts(i int) ICollector_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_stmtsContext)
}

func (s *CollectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector(s)
	}
}

func (s *CollectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector(s)
	}
}

func (p *SyslParser) Collector() (localctx ICollectorContext) {
	localctx = NewCollectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SyslParserRULE_collector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Match(SyslParserCOLLECTOR)
	}
	{
		p.SetState(989)
		p.Match(SyslParserCOLON)
	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(990)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(991)
			p.Match(SyslParserINDENT)
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
			{
				p.SetState(992)
				p.Collector_stmts()
			}

			p.SetState(995)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(997)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(SyslParserDISTANCE, 0)
}

func (s *EventContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *EventContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EventContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *EventContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *EventContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *EventContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *EventContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *EventContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *EventContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *SyslParser) Event() (localctx IEventContext) {
	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SyslParserRULE_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(SyslParserDISTANCE)
	}
	{
		p.SetState(1002)
		p.Name_str()
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(1003)
			p.Params()
		}

	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1006)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1009)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1010)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1011)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1012)
				p.Statements()
			}

			p.SetState(1015)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1017)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscribeContext is an interface to support dynamic dispatch.
type ISubscribeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscribeContext differentiates from other interfaces.
	IsSubscribeContext()
}

type SubscribeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscribeContext() *SubscribeContext {
	var p = new(SubscribeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscribe
	return p
}

func (*SubscribeContext) IsSubscribeContext() {}

func NewSubscribeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscribeContext {
	var p = new(SubscribeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscribe

	return p
}

func (s *SubscribeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscribeContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscribeContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *SubscribeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *SubscribeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *SubscribeContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *SubscribeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *SubscribeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *SubscribeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *SubscribeContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *SubscribeContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *SubscribeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscribeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscribeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscribe(s)
	}
}

func (s *SubscribeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscribe(s)
	}
}

func (p *SyslParser) Subscribe() (localctx ISubscribeContext) {
	localctx = NewSubscribeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SyslParserRULE_subscribe)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.App_name()
	}
	{
		p.SetState(1022)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1023)
		p.Name_str()
	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1024)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1027)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1028)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1029)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1031)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SyslParserAT-44))|(1<<(SyslParserPIPE-44))|(1<<(SyslParserQSTRING-44))|(1<<(SyslParserSYSL_COMMENT-44))|(1<<(SyslParserTEXT_LINE-44))|(1<<(SyslParserName-44)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1030)
				p.Statements()
			}

			p.SetState(1033)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1035)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IView_type_specContext is an interface to support dynamic dispatch.
type IView_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_type_specContext differentiates from other interfaces.
	IsView_type_specContext()
}

type View_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_type_specContext() *View_type_specContext {
	var p = new(View_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_type_spec
	return p
}

func (*View_type_specContext) IsView_type_specContext() {}

func NewView_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_type_specContext {
	var p = new(View_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_type_spec

	return p
}

func (s *View_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *View_type_specContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *View_type_specContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *View_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_type_spec(s)
	}
}

func (s *View_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_type_spec(s)
	}
}

func (p *SyslParser) View_type_spec() (localctx IView_type_specContext) {
	localctx = NewView_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SyslParserRULE_view_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1041)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1039)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1040)
			p.Types()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) E_DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIGITS, 0)
}

func (s *LiteralContext) E_DECIMAL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DECIMAL, 0)
}

func (s *LiteralContext) E_STRING_DBL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_DBL, 0)
}

func (s *LiteralContext) E_STRING_SINGLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_SINGLE, 0)
}

func (s *LiteralContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *LiteralContext) E_TRUE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TRUE, 0)
}

func (s *LiteralContext) E_FALSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FALSE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *SyslParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SyslParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1043)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-116)&-(0x1f+1)) == 0 && ((1<<uint((_la-116)))&((1<<(SyslParserE_TRUE-116))|(1<<(SyslParserE_FALSE-116))|(1<<(SyslParserE_NULL-116))|(1<<(SyslParserE_STRING_DBL-116))|(1<<(SyslParserE_STRING_SINGLE-116))|(1<<(SyslParserE_DECIMAL-116))|(1<<(SyslParserE_DIGITS-116)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_table_of_opContext is an interface to support dynamic dispatch.
type IExpr_table_of_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_table_of_opContext differentiates from other interfaces.
	IsExpr_table_of_opContext()
}

type Expr_table_of_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_table_of_opContext() *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_op
	return p
}

func (*Expr_table_of_opContext) IsExpr_table_of_opContext() {}

func NewExpr_table_of_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_op

	return p
}

func (s *Expr_table_of_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_opContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_opContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_NULLSAFE_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULLSAFE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_op(s)
	}
}

func (s *Expr_table_of_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_op(s)
	}
}

func (p *SyslParser) Expr_table_of_op() (localctx IExpr_table_of_opContext) {
	localctx = NewExpr_table_of_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SyslParserRULE_expr_table_of_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1045)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_NULLSAFE_DOT || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_TABLE_OF {
		{
			p.SetState(1046)
			p.Match(SyslParserE_TABLE_OF)
		}

	}
	{
		p.SetState(1049)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IFunc_argContext is an interface to support dynamic dispatch.
type IFunc_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argContext differentiates from other interfaces.
	IsFunc_argContext()
}

type Func_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argContext() *Func_argContext {
	var p = new(Func_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_arg
	return p
}

func (*Func_argContext) IsFunc_argContext() {}

func NewFunc_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argContext {
	var p = new(Func_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_arg

	return p
}

func (s *Func_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_arg(s)
	}
}

func (s *Func_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_arg(s)
	}
}

func (p *SyslParser) Func_arg() (localctx IFunc_argContext) {
	localctx = NewFunc_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SyslParserRULE_func_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Expr()
	}

	return localctx
}

// IFunc_argsContext is an interface to support dynamic dispatch.
type IFunc_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argsContext differentiates from other interfaces.
	IsFunc_argsContext()
}

type Func_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argsContext() *Func_argsContext {
	var p = new(Func_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_args
	return p
}

func (*Func_argsContext) IsFunc_argsContext() {}

func NewFunc_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argsContext {
	var p = new(Func_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_args

	return p
}

func (s *Func_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argsContext) AllFunc_arg() []IFunc_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunc_argContext)(nil)).Elem())
	var tst = make([]IFunc_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunc_argContext)
		}
	}

	return tst
}

func (s *Func_argsContext) Func_arg(i int) IFunc_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunc_argContext)
}

func (s *Func_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Func_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Func_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_args(s)
	}
}

func (s *Func_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_args(s)
	}
}

func (p *SyslParser) Func_args() (localctx IFunc_argsContext) {
	localctx = NewFunc_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SyslParserRULE_func_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Func_arg()
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1054)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1055)
			p.Func_arg()
		}

		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_func
	return p
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_funcContext) E_FUNC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FUNC, 0)
}

func (s *Expr_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_funcContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Expr_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *SyslParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SyslParserRULE_expr_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1061)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserNativeDataTypes || _la == SyslParserE_FUNC || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1062)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
		{
			p.SetState(1063)
			p.Func_args()
		}

	}
	{
		p.SetState(1066)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IRank_exprContext is an interface to support dynamic dispatch.
type IRank_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_exprContext differentiates from other interfaces.
	IsRank_exprContext()
}

type Rank_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_exprContext() *Rank_exprContext {
	var p = new(Rank_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr
	return p
}

func (*Rank_exprContext) IsRank_exprContext() {}

func NewRank_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_exprContext {
	var p = new(Rank_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr

	return p
}

func (s *Rank_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Rank_exprContext) E_ASC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ASC, 0)
}

func (s *Rank_exprContext) E_DESC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DESC, 0)
}

func (s *Rank_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr(s)
	}
}

func (s *Rank_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr(s)
	}
}

func (p *SyslParser) Rank_expr() (localctx IRank_exprContext) {
	localctx = NewRank_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SyslParserRULE_rank_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1068)
		p.Expr()
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ASC || _la == SyslParserE_DESC {
		p.SetState(1069)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_ASC || _la == SyslParserE_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IRank_expr_listContext is an interface to support dynamic dispatch.
type IRank_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_expr_listContext differentiates from other interfaces.
	IsRank_expr_listContext()
}

type Rank_expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_expr_listContext() *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr_list
	return p
}

func (*Rank_expr_listContext) IsRank_expr_listContext() {}

func NewRank_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr_list

	return p
}

func (s *Rank_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_expr_listContext) AllRank_expr() []IRank_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRank_exprContext)(nil)).Elem())
	var tst = make([]IRank_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRank_exprContext)
		}
	}

	return tst
}

func (s *Rank_expr_listContext) Rank_expr(i int) IRank_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRank_exprContext)
}

func (s *Rank_expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Rank_expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Rank_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr_list(s)
	}
}

func (s *Rank_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr_list(s)
	}
}

func (p *SyslParser) Rank_expr_list() (localctx IRank_expr_listContext) {
	localctx = NewRank_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SyslParserRULE_rank_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		p.Rank_expr()
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1073)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1074)
			p.Rank_expr()
		}

		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_rank_funcContext is an interface to support dynamic dispatch.
type IExpr_rank_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_rank_funcContext differentiates from other interfaces.
	IsExpr_rank_funcContext()
}

type Expr_rank_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_rank_funcContext() *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rank_func
	return p
}

func (*Expr_rank_funcContext) IsExpr_rank_funcContext() {}

func NewExpr_rank_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rank_func

	return p
}

func (s *Expr_rank_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_rank_funcContext) E_RELOPS_RANK() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_RANK, 0)
}

func (s *Expr_rank_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_rank_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_rank_funcContext) E_AS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_AS, 0)
}

func (s *Expr_rank_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_rank_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_rank_funcContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *Expr_rank_funcContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Expr_rank_funcContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_rank_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_rank_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_rank_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rank_func(s)
	}
}

func (s *Expr_rank_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rank_func(s)
	}
}

func (p *SyslParser) Expr_rank_func() (localctx IExpr_rank_funcContext) {
	localctx = NewExpr_rank_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SyslParserRULE_expr_rank_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Match(SyslParserE_RELOPS_RANK)
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1081)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1082)
			p.View_type_spec()
		}
		{
			p.SetState(1083)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1087)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1088)
		p.Rank_expr_list()
	}
	{
		p.SetState(1089)
		p.Match(SyslParserE_AS)
	}
	{
		p.SetState(1090)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1091)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_agg_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_agg_funcContext differentiates from other interfaces.
	IsExpr_agg_funcContext()
}

type Expr_agg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_funcContext() *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_agg_func
	return p
}

func (*Expr_agg_funcContext) IsExpr_agg_funcContext() {}

func NewExpr_agg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_agg_func

	return p
}

func (s *Expr_agg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_funcContext) E_RELOPS_AGG() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_AGG, 0)
}

func (s *Expr_agg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_agg_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_agg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_agg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_agg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_agg_func(s)
	}
}

func (s *Expr_agg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_agg_func(s)
	}
}

func (p *SyslParser) Expr_agg_func() (localctx IExpr_agg_funcContext) {
	localctx = NewExpr_agg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SyslParserRULE_expr_agg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(SyslParserE_RELOPS_AGG)
	}
	{
		p.SetState(1094)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1095)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1098)
		p.Func_args()
	}
	{
		p.SetState(1099)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_scope_varContext is an interface to support dynamic dispatch.
type IE_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_scope_varContext differentiates from other interfaces.
	IsE_scope_varContext()
}

type E_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_scope_varContext() *E_scope_varContext {
	var p = new(E_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_scope_var
	return p
}

func (*E_scope_varContext) IsE_scope_varContext() {}

func NewE_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_scope_varContext {
	var p = new(E_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_scope_var

	return p
}

func (s *E_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *E_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *E_scope_varContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *E_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_scope_var(s)
	}
}

func (s *E_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_scope_var(s)
	}
}

func (p *SyslParser) E_scope_var() (localctx IE_scope_varContext) {
	localctx = NewE_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SyslParserRULE_e_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1102)
		p.Match(SyslParserE_COLON)
	}

	return localctx
}

// IFirst_func_targetContext is an interface to support dynamic dispatch.
type IFirst_func_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFirst_func_targetContext differentiates from other interfaces.
	IsFirst_func_targetContext()
}

type First_func_targetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirst_func_targetContext() *First_func_targetContext {
	var p = new(First_func_targetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_first_func_target
	return p
}

func (*First_func_targetContext) IsFirst_func_targetContext() {}

func NewFirst_func_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *First_func_targetContext {
	var p = new(First_func_targetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_first_func_target

	return p
}

func (s *First_func_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *First_func_targetContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *First_func_targetContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *First_func_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *First_func_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *First_func_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFirst_func_target(s)
	}
}

func (s *First_func_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFirst_func_target(s)
	}
}

func (p *SyslParser) First_func_target() (localctx IFirst_func_targetContext) {
	localctx = NewFirst_func_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SyslParserRULE_first_func_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1106)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1104)
			p.Match(SyslParserE_NULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1105)
			p.Expr()
		}

	}

	return localctx
}

// IExpr_first_funcContext is an interface to support dynamic dispatch.
type IExpr_first_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_first_funcContext differentiates from other interfaces.
	IsExpr_first_funcContext()
}

type Expr_first_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_first_funcContext() *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_first_func
	return p
}

func (*Expr_first_funcContext) IsExpr_first_funcContext() {}

func NewExpr_first_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_first_func

	return p
}

func (s *Expr_first_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_first_funcContext) E_RELOPS_FIRST() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FIRST, 0)
}

func (s *Expr_first_funcContext) First_func_target() IFirst_func_targetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFirst_func_targetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFirst_func_targetContext)
}

func (s *Expr_first_funcContext) E_BY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_BY, 0)
}

func (s *Expr_first_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_first_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_first_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_first_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_first_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_first_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_first_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_first_func(s)
	}
}

func (s *Expr_first_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_first_func(s)
	}
}

func (p *SyslParser) Expr_first_func() (localctx IExpr_first_funcContext) {
	localctx = NewExpr_first_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SyslParserRULE_expr_first_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1108)
		p.Match(SyslParserE_RELOPS_FIRST)
	}
	{
		p.SetState(1109)
		p.First_func_target()
	}
	{
		p.SetState(1110)
		p.Match(SyslParserE_BY)
	}
	{
		p.SetState(1111)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1112)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1115)
		p.Rank_expr_list()
	}
	{
		p.SetState(1116)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_single_arg_funcContext is an interface to support dynamic dispatch.
type IE_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_single_arg_funcContext differentiates from other interfaces.
	IsE_single_arg_funcContext()
}

type E_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_single_arg_funcContext() *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_single_arg_func
	return p
}

func (*E_single_arg_funcContext) IsE_single_arg_funcContext() {}

func NewE_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_single_arg_func

	return p
}

func (s *E_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *E_single_arg_funcContext) E_RELOPS_WHERE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_WHERE, 0)
}

func (s *E_single_arg_funcContext) E_RELOPS_FLATTEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FLATTEN, 0)
}

func (s *E_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_single_arg_func(s)
	}
}

func (s *E_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_single_arg_func(s)
	}
}

func (p *SyslParser) E_single_arg_func() (localctx IE_single_arg_funcContext) {
	localctx = NewE_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SyslParserRULE_e_single_arg_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1118)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_RELOPS_WHERE || _la == SyslParserE_RELOPS_FLATTEN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_single_arg_funcContext is an interface to support dynamic dispatch.
type IExpr_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_arg_funcContext differentiates from other interfaces.
	IsExpr_single_arg_funcContext()
}

type Expr_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_arg_funcContext() *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_arg_func
	return p
}

func (*Expr_single_arg_funcContext) IsExpr_single_arg_funcContext() {}

func NewExpr_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_arg_func

	return p
}

func (s *Expr_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_arg_funcContext) E_single_arg_func() IE_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_single_arg_funcContext)
}

func (s *Expr_single_arg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_single_arg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_arg_func(s)
	}
}

func (s *Expr_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_arg_func(s)
	}
}

func (p *SyslParser) Expr_single_arg_func() (localctx IExpr_single_arg_funcContext) {
	localctx = NewExpr_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SyslParserRULE_expr_single_arg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.E_single_arg_func()
	}
	{
		p.SetState(1121)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1122)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1125)
		p.Expr()
	}
	{
		p.SetState(1126)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_any_funcContext is an interface to support dynamic dispatch.
type IExpr_any_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_any_funcContext differentiates from other interfaces.
	IsExpr_any_funcContext()
}

type Expr_any_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_any_funcContext() *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_any_func
	return p
}

func (*Expr_any_funcContext) IsExpr_any_funcContext() {}

func NewExpr_any_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_any_func

	return p
}

func (s *Expr_any_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_any_funcContext) E_RELOPS_ANY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_ANY, 0)
}

func (s *Expr_any_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_any_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_any_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_any_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_any_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_any_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_any_func(s)
	}
}

func (s *Expr_any_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_any_func(s)
	}
}

func (p *SyslParser) Expr_any_func() (localctx IExpr_any_funcContext) {
	localctx = NewExpr_any_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SyslParserRULE_expr_any_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1128)
		p.Match(SyslParserE_RELOPS_ANY)
	}
	{
		p.SetState(1129)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1130)
		p.Expr()
	}
	{
		p.SetState(1131)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_single_or_nullContext is an interface to support dynamic dispatch.
type IExpr_single_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_or_nullContext differentiates from other interfaces.
	IsExpr_single_or_nullContext()
}

type Expr_single_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_or_nullContext() *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_or_null
	return p
}

func (*Expr_single_or_nullContext) IsExpr_single_or_nullContext() {}

func NewExpr_single_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_or_null

	return p
}

func (s *Expr_single_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_or_nullContext) E_RELOPS_SINGLE_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SINGLE_NULL, 0)
}

func (s *Expr_single_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_or_null(s)
	}
}

func (s *Expr_single_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_or_null(s)
	}
}

func (p *SyslParser) Expr_single_or_null() (localctx IExpr_single_or_nullContext) {
	localctx = NewExpr_single_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SyslParserRULE_expr_single_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Match(SyslParserE_RELOPS_SINGLE_NULL)
	}

	return localctx
}

// IExpr_snapshotContext is an interface to support dynamic dispatch.
type IExpr_snapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_snapshotContext differentiates from other interfaces.
	IsExpr_snapshotContext()
}

type Expr_snapshotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_snapshotContext() *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_snapshot
	return p
}

func (*Expr_snapshotContext) IsExpr_snapshotContext() {}

func NewExpr_snapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_snapshot

	return p
}

func (s *Expr_snapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_snapshotContext) E_RELOPS_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SNAPSHOT, 0)
}

func (s *Expr_snapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_snapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_snapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_snapshot(s)
	}
}

func (s *Expr_snapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_snapshot(s)
	}
}

func (p *SyslParser) Expr_snapshot() (localctx IExpr_snapshotContext) {
	localctx = NewExpr_snapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SyslParserRULE_expr_snapshot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.Match(SyslParserE_RELOPS_SNAPSHOT)
	}

	return localctx
}

// IExpr_countContext is an interface to support dynamic dispatch.
type IExpr_countContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_countContext differentiates from other interfaces.
	IsExpr_countContext()
}

type Expr_countContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_countContext() *Expr_countContext {
	var p = new(Expr_countContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_count
	return p
}

func (*Expr_countContext) IsExpr_countContext() {}

func NewExpr_countContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_countContext {
	var p = new(Expr_countContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_count

	return p
}

func (s *Expr_countContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_countContext) E_RELOPS_COUNT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_COUNT, 0)
}

func (s *Expr_countContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_countContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_countContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_count(s)
	}
}

func (s *Expr_countContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_count(s)
	}
}

func (p *SyslParser) Expr_count() (localctx IExpr_countContext) {
	localctx = NewExpr_countContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SyslParserRULE_expr_count)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Match(SyslParserE_RELOPS_COUNT)
	}

	return localctx
}

// IExpr_navigate_attrContext is an interface to support dynamic dispatch.
type IExpr_navigate_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigate_attrContext differentiates from other interfaces.
	IsExpr_navigate_attrContext()
}

type Expr_navigate_attrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigate_attrContext() *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate_attr
	return p
}

func (*Expr_navigate_attrContext) IsExpr_navigate_attrContext() {}

func NewExpr_navigate_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate_attr

	return p
}

func (s *Expr_navigate_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigate_attrContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigate_attrContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_navigate_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigate_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigate_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate_attr(s)
	}
}

func (s *Expr_navigate_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate_attr(s)
	}
}

func (p *SyslParser) Expr_navigate_attr() (localctx IExpr_navigate_attrContext) {
	localctx = NewExpr_navigate_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SyslParserRULE_expr_navigate_attr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_DOT {
		{
			p.SetState(1139)
			p.Match(SyslParserE_DOT)
		}

	}
	{
		p.SetState(1142)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IExpr_navigateContext is an interface to support dynamic dispatch.
type IExpr_navigateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigateContext differentiates from other interfaces.
	IsExpr_navigateContext()
}

type Expr_navigateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigateContext() *Expr_navigateContext {
	var p = new(Expr_navigateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate
	return p
}

func (*Expr_navigateContext) IsExpr_navigateContext() {}

func NewExpr_navigateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigateContext {
	var p = new(Expr_navigateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate

	return p
}

func (s *Expr_navigateContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigateContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *Expr_navigateContext) Expr_navigate_attr() IExpr_navigate_attrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigate_attrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigate_attrContext)
}

func (s *Expr_navigateContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *Expr_navigateContext) E_VIA() antlr.TerminalNode {
	return s.GetToken(SyslParserE_VIA, 0)
}

func (s *Expr_navigateContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigateContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Expr_navigateContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Expr_navigateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate(s)
	}
}

func (s *Expr_navigateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate(s)
	}
}

func (p *SyslParser) Expr_navigate() (localctx IExpr_navigateContext) {
	localctx = NewExpr_navigateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SyslParserRULE_expr_navigate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1144)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1147)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF {
		p.SetState(1148)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1151)
		p.Expr_navigate_attr()
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1152)
			p.Match(SyslParserE_VIA)
		}
		{
			p.SetState(1153)
			p.Match(SyslParserE_Name)
		}

	}

	return localctx
}

// IMatching_rhsContext is an interface to support dynamic dispatch.
type IMatching_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatching_rhsContext differentiates from other interfaces.
	IsMatching_rhsContext()
}

type Matching_rhsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatching_rhsContext() *Matching_rhsContext {
	var p = new(Matching_rhsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_matching_rhs
	return p
}

func (*Matching_rhsContext) IsMatching_rhsContext() {}

func NewMatching_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Matching_rhsContext {
	var p = new(Matching_rhsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_matching_rhs

	return p
}

func (s *Matching_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Matching_rhsContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *Matching_rhsContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Matching_rhsContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *Matching_rhsContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Matching_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Matching_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Matching_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMatching_rhs(s)
	}
}

func (s *Matching_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMatching_rhs(s)
	}
}

func (p *SyslParser) Matching_rhs() (localctx IMatching_rhsContext) {
	localctx = NewMatching_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SyslParserRULE_matching_rhs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1160)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1156)
			p.Expr_table_of_op()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1157)
			p.Expr_navigate()
		}

	case SyslParserE_OPEN_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1158)
			p.AtomT_paren()
		}

	case SyslParserE_Name:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1159)
			p.Match(SyslParserE_Name)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISquiggly_argsContext is an interface to support dynamic dispatch.
type ISquiggly_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquiggly_argsContext differentiates from other interfaces.
	IsSquiggly_argsContext()
}

type Squiggly_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquiggly_argsContext() *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_squiggly_args
	return p
}

func (*Squiggly_argsContext) IsSquiggly_argsContext() {}

func NewSquiggly_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_squiggly_args

	return p
}

func (s *Squiggly_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Squiggly_argsContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Squiggly_argsContext) AllE_Name() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_Name)
}

func (s *Squiggly_argsContext) E_Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, i)
}

func (s *Squiggly_argsContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Squiggly_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Squiggly_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Squiggly_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Squiggly_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Squiggly_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSquiggly_args(s)
	}
}

func (s *Squiggly_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSquiggly_args(s)
	}
}

func (p *SyslParser) Squiggly_args() (localctx ISquiggly_argsContext) {
	localctx = NewSquiggly_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SyslParserRULE_squiggly_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1163)
		p.Match(SyslParserE_Name)
	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1164)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1165)
			p.Match(SyslParserE_Name)
		}

		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1171)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IExpr_matchingContext is an interface to support dynamic dispatch.
type IExpr_matchingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_matchingContext differentiates from other interfaces.
	IsExpr_matchingContext()
}

type Expr_matchingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_matchingContext() *Expr_matchingContext {
	var p = new(Expr_matchingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_matching
	return p
}

func (*Expr_matchingContext) IsExpr_matchingContext() {}

func NewExpr_matchingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_matchingContext {
	var p = new(Expr_matchingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_matching

	return p
}

func (s *Expr_matchingContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_matchingContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *Expr_matchingContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_matchingContext) Matching_rhs() IMatching_rhsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatching_rhsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatching_rhsContext)
}

func (s *Expr_matchingContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *Expr_matchingContext) Squiggly_args() ISquiggly_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquiggly_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISquiggly_argsContext)
}

func (s *Expr_matchingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_matchingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_matchingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_matching(s)
	}
}

func (s *Expr_matchingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_matching(s)
	}
}

func (p *SyslParser) Expr_matching() (localctx IExpr_matchingContext) {
	localctx = NewExpr_matchingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SyslParserRULE_expr_matching)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_NOT {
		{
			p.SetState(1173)
			p.Match(SyslParserE_NOT)
		}

	}
	{
		p.SetState(1176)
		p.Match(SyslParserE_TILDE)
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SQ_OPEN {
		{
			p.SetState(1177)
			p.Squiggly_args()
		}

	}
	{
		p.SetState(1180)
		p.Match(SyslParserE_ANGLE_CLOSE)
	}
	{
		p.SetState(1181)
		p.Matching_rhs()
	}

	return localctx
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_relop
	return p
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *RelopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *RelopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *RelopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *RelopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *RelopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *RelopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *RelopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *RelopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *RelopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *RelopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRelop(s)
	}
}

func (s *RelopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRelop(s)
	}
}

func (p *SyslParser) Relop() (localctx IRelopContext) {
	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SyslParserRULE_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1194)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1183)
			p.Expr_table_of_op()
		}

	case SyslParserE_RELOPS_RANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1184)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1185)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1186)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1187)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1188)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1189)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1190)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1191)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1192)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1193)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_itemContext is an interface to support dynamic dispatch.
type IList_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_itemContext differentiates from other interfaces.
	IsList_itemContext()
}

type List_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_itemContext() *List_itemContext {
	var p = new(List_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_list_item
	return p
}

func (*List_itemContext) IsList_itemContext() {}

func NewList_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_itemContext {
	var p = new(List_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_list_item

	return p
}

func (s *List_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterList_item(s)
	}
}

func (s *List_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitList_item(s)
	}
}

func (p *SyslParser) List_item() (localctx IList_itemContext) {
	localctx = NewList_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SyslParserRULE_list_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1196)
		p.Expr()
	}

	return localctx
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_list
	return p
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllList_item() []IList_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_itemContext)(nil)).Elem())
	var tst = make([]IList_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_itemContext)
		}
	}

	return tst
}

func (s *Expr_listContext) List_item(i int) IList_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_itemContext)
}

func (s *Expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (p *SyslParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SyslParserRULE_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		p.List_item()
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1199)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1200)
			p.List_item()
		}

		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_setContext is an interface to support dynamic dispatch.
type IExpr_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_setContext differentiates from other interfaces.
	IsExpr_setContext()
}

type Expr_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_setContext() *Expr_setContext {
	var p = new(Expr_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_set
	return p
}

func (*Expr_setContext) IsExpr_setContext() {}

func NewExpr_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_setContext {
	var p = new(Expr_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_set

	return p
}

func (s *Expr_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_setContext) E_CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_OPEN, 0)
}

func (s *Expr_setContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_setContext) E_CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_CLOSE, 0)
}

func (s *Expr_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_set(s)
	}
}

func (s *Expr_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_set(s)
	}
}

func (p *SyslParser) Expr_set() (localctx IExpr_setContext) {
	localctx = NewExpr_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SyslParserRULE_expr_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Match(SyslParserE_CURLY_OPEN)
	}
	{
		p.SetState(1207)
		p.Expr_list()
	}
	{
		p.SetState(1208)
		p.Match(SyslParserE_CURLY_CLOSE)
	}

	return localctx
}

// IEmpty_tupleContext is an interface to support dynamic dispatch.
type IEmpty_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_tupleContext differentiates from other interfaces.
	IsEmpty_tupleContext()
}

type Empty_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_tupleContext() *Empty_tupleContext {
	var p = new(Empty_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_empty_tuple
	return p
}

func (*Empty_tupleContext) IsEmpty_tupleContext() {}

func NewEmpty_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_tupleContext {
	var p = new(Empty_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_empty_tuple

	return p
}

func (s *Empty_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_tupleContext) E_EMPTY_TUPLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EMPTY_TUPLE, 0)
}

func (s *Empty_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEmpty_tuple(s)
	}
}

func (s *Empty_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEmpty_tuple(s)
	}
}

func (p *SyslParser) Empty_tuple() (localctx IEmpty_tupleContext) {
	localctx = NewEmpty_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SyslParserRULE_empty_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Match(SyslParserE_EMPTY_TUPLE)
	}

	return localctx
}

// IAtom_dot_relopContext is an interface to support dynamic dispatch.
type IAtom_dot_relopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_dot_relopContext differentiates from other interfaces.
	IsAtom_dot_relopContext()
}

type Atom_dot_relopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_dot_relopContext() *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom_dot_relop
	return p
}

func (*Atom_dot_relopContext) IsAtom_dot_relopContext() {}

func NewAtom_dot_relopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom_dot_relop

	return p
}

func (s *Atom_dot_relopContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_dot_relopContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Atom_dot_relopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *Atom_dot_relopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *Atom_dot_relopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *Atom_dot_relopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *Atom_dot_relopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *Atom_dot_relopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *Atom_dot_relopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Atom_dot_relopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *Atom_dot_relopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_dot_relopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_dot_relopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom_dot_relop(s)
	}
}

func (s *Atom_dot_relopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom_dot_relop(s)
	}
}

func (p *SyslParser) Atom_dot_relop() (localctx IAtom_dot_relopContext) {
	localctx = NewAtom_dot_relopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SyslParserRULE_atom_dot_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.Match(SyslParserE_DOT)
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_RELOPS_RANK:
		{
			p.SetState(1213)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		{
			p.SetState(1214)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		{
			p.SetState(1215)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		{
			p.SetState(1216)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		{
			p.SetState(1217)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		{
			p.SetState(1218)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		{
			p.SetState(1219)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		{
			p.SetState(1220)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		{
			p.SetState(1221)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		{
			p.SetState(1222)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomT_implied_dotContext is an interface to support dynamic dispatch.
type IAtomT_implied_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_implied_dotContext differentiates from other interfaces.
	IsAtomT_implied_dotContext()
}

type AtomT_implied_dotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_implied_dotContext() *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_implied_dot
	return p
}

func (*AtomT_implied_dotContext) IsAtomT_implied_dotContext() {}

func NewAtomT_implied_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_implied_dot

	return p
}

func (s *AtomT_implied_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_implied_dotContext) Atom_dot_relop() IAtom_dot_relopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_dot_relopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_dot_relopContext)
}

func (s *AtomT_implied_dotContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *AtomT_implied_dotContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *AtomT_implied_dotContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *AtomT_implied_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_implied_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_implied_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_implied_dot(s)
	}
}

func (s *AtomT_implied_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_implied_dot(s)
	}
}

func (p *SyslParser) AtomT_implied_dot() (localctx IAtomT_implied_dotContext) {
	localctx = NewAtomT_implied_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SyslParserRULE_atomT_implied_dot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1225)
			p.Atom_dot_relop()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1226)
			p.Expr_navigate()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1227)
			p.Expr_matching()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1228)
			p.Expr_table_of_op()
		}

	}

	return localctx
}

// IAtomT_nameContext is an interface to support dynamic dispatch.
type IAtomT_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_nameContext differentiates from other interfaces.
	IsAtomT_nameContext()
}

type AtomT_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_nameContext() *AtomT_nameContext {
	var p = new(AtomT_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_name
	return p
}

func (*AtomT_nameContext) IsAtomT_nameContext() {}

func NewAtomT_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_nameContext {
	var p = new(AtomT_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_name

	return p
}

func (s *AtomT_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_nameContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *AtomT_nameContext) E_WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserE_WHATEVER, 0)
}

func (s *AtomT_nameContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *AtomT_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_name(s)
	}
}

func (s *AtomT_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_name(s)
	}
}

func (p *SyslParser) AtomT_name() (localctx IAtomT_nameContext) {
	localctx = NewAtomT_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SyslParserRULE_atomT_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1231)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_WHATEVER || _la == SyslParserE_Name || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAtomT_parenContext is an interface to support dynamic dispatch.
type IAtomT_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_parenContext differentiates from other interfaces.
	IsAtomT_parenContext()
}

type AtomT_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_parenContext() *AtomT_parenContext {
	var p = new(AtomT_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_paren
	return p
}

func (*AtomT_parenContext) IsAtomT_parenContext() {}

func NewAtomT_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_parenContext {
	var p = new(AtomT_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_paren

	return p
}

func (s *AtomT_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_parenContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *AtomT_parenContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AtomT_parenContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *AtomT_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_paren(s)
	}
}

func (s *AtomT_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_paren(s)
	}
}

func (p *SyslParser) AtomT_paren() (localctx IAtomT_parenContext) {
	localctx = NewAtomT_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SyslParserRULE_atomT_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1234)
		p.Expr()
	}
	{
		p.SetState(1235)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_atom_listContext is an interface to support dynamic dispatch.
type IExpr_atom_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_atom_listContext differentiates from other interfaces.
	IsExpr_atom_listContext()
}

type Expr_atom_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atom_listContext() *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_atom_list
	return p
}

func (*Expr_atom_listContext) IsExpr_atom_listContext() {}

func NewExpr_atom_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_atom_list

	return p
}

func (s *Expr_atom_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atom_listContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Expr_atom_listContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_atom_listContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Expr_atom_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atom_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atom_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_atom_list(s)
	}
}

func (s *Expr_atom_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_atom_list(s)
	}
}

func (p *SyslParser) Expr_atom_list() (localctx IExpr_atom_listContext) {
	localctx = NewExpr_atom_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SyslParserRULE_expr_atom_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1238)
		p.Expr_list()
	}
	{
		p.SetState(1239)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IAtomTContext is an interface to support dynamic dispatch.
type IAtomTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomTContext differentiates from other interfaces.
	IsAtomTContext()
}

type AtomTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomTContext() *AtomTContext {
	var p = new(AtomTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT
	return p
}

func (*AtomTContext) IsAtomTContext() {}

func NewAtomTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomTContext {
	var p = new(AtomTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT

	return p
}

func (s *AtomTContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomTContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *AtomTContext) Expr_set() IExpr_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_setContext)
}

func (s *AtomTContext) Expr_atom_list() IExpr_atom_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_atom_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_atom_listContext)
}

func (s *AtomTContext) Empty_tuple() IEmpty_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_tupleContext)
}

func (s *AtomTContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *AtomTContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomTContext) AtomT_implied_dot() IAtomT_implied_dotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_implied_dotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_implied_dotContext)
}

func (s *AtomTContext) AtomT_name() IAtomT_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_nameContext)
}

func (s *AtomTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT(s)
	}
}

func (s *AtomTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT(s)
	}
}

func (p *SyslParser) AtomT() (localctx IAtomTContext) {
	localctx = NewAtomTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SyslParserRULE_atomT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1241)
			p.Expr_func()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1242)
			p.Expr_set()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1243)
			p.Expr_atom_list()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1244)
			p.Empty_tuple()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1245)
			p.AtomT_paren()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1246)
			p.Literal()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1247)
			p.AtomT_implied_dot()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1248)
			p.AtomT_name()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AtomT() IAtomTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomTContext)
}

func (s *AtomContext) AllRelop() []IRelopContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelopContext)(nil)).Elem())
	var tst = make([]IRelopContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelopContext)
		}
	}

	return tst
}

func (s *AtomContext) Relop(i int) IRelopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelopContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *SyslParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SyslParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.AtomT()
	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1252)
				p.Relop()
			}

		}
		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerTContext is an interface to support dynamic dispatch.
type IPowerTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerTContext differentiates from other interfaces.
	IsPowerTContext()
}

type PowerTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerTContext() *PowerTContext {
	var p = new(PowerTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_powerT
	return p
}

func (*PowerTContext) IsPowerTContext() {}

func NewPowerTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerTContext {
	var p = new(PowerTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_powerT

	return p
}

func (s *PowerTContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerTContext) E_POW() antlr.TerminalNode {
	return s.GetToken(SyslParserE_POW, 0)
}

func (s *PowerTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *PowerTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPowerT(s)
	}
}

func (s *PowerTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPowerT(s)
	}
}

func (p *SyslParser) PowerT() (localctx IPowerTContext) {
	localctx = NewPowerTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SyslParserRULE_powerT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Match(SyslParserE_POW)
	}
	{
		p.SetState(1259)
		p.UnaryTerm()
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) PowerT() IPowerTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerTContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *SyslParser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SyslParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1261)
		p.Atom()
	}
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1262)
			p.PowerT()
		}

	}

	return localctx
}

// IUnaryTermContext is an interface to support dynamic dispatch.
type IUnaryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryTermContext differentiates from other interfaces.
	IsUnaryTermContext()
}

type UnaryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryTermContext() *UnaryTermContext {
	var p = new(UnaryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_unaryTerm
	return p
}

func (*UnaryTermContext) IsUnaryTermContext() {}

func NewUnaryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryTermContext {
	var p = new(UnaryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_unaryTerm

	return p
}

func (s *UnaryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryTermContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *UnaryTermContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *UnaryTermContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *UnaryTermContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *UnaryTermContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *UnaryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnaryTerm(s)
	}
}

func (s *UnaryTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnaryTerm(s)
	}
}

func (p *SyslParser) UnaryTerm() (localctx IUnaryTermContext) {
	localctx = NewUnaryTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SyslParserRULE_unaryTerm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		p.SetState(1265)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-95)&-(0x1f+1)) == 0 && ((1<<uint((_la-95)))&((1<<(SyslParserE_PLUS-95))|(1<<(SyslParserE_MINUS-95))|(1<<(SyslParserE_TILDE-95))|(1<<(SyslParserE_NOT-95)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1268)
		p.Power()
	}

	return localctx
}

// ITermTContext is an interface to support dynamic dispatch.
type ITermTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermTContext differentiates from other interfaces.
	IsTermTContext()
}

type TermTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermTContext() *TermTContext {
	var p = new(TermTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_termT
	return p
}

func (*TermTContext) IsTermTContext() {}

func NewTermTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermTContext {
	var p = new(TermTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_termT

	return p
}

func (s *TermTContext) GetParser() antlr.Parser { return s.parser }

func (s *TermTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermTContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *TermTContext) E_DIVIDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIVIDE, 0)
}

func (s *TermTContext) E_MOD() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MOD, 0)
}

func (s *TermTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTermT(s)
	}
}

func (s *TermTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTermT(s)
	}
}

func (p *SyslParser) TermT() (localctx ITermTContext) {
	localctx = NewTermTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SyslParserRULE_termT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1270)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SyslParserE_DIVIDE-96))|(1<<(SyslParserE_MOD-96))|(1<<(SyslParserE_STAR-96)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1271)
		p.UnaryTerm()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermContext) AllTermT() []ITermTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermTContext)(nil)).Elem())
	var tst = make([]ITermTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermTContext)
		}
	}

	return tst
}

func (s *TermContext) TermT(i int) ITermTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermTContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *SyslParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SyslParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.UnaryTerm()
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1274)
				p.TermT()
			}

		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext())
	}

	return localctx
}

// IBinexprTContext is an interface to support dynamic dispatch.
type IBinexprTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprTContext differentiates from other interfaces.
	IsBinexprTContext()
}

type BinexprTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprTContext() *BinexprTContext {
	var p = new(BinexprTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexprT
	return p
}

func (*BinexprTContext) IsBinexprTContext() {}

func NewBinexprTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprTContext {
	var p = new(BinexprTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexprT

	return p
}

func (s *BinexprTContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprTContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprTContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *BinexprTContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *BinexprTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexprT(s)
	}
}

func (s *BinexprTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexprT(s)
	}
}

func (p *SyslParser) BinexprT() (localctx IBinexprTContext) {
	localctx = NewBinexprTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SyslParserRULE_binexprT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1280)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_PLUS || _la == SyslParserE_MINUS) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1281)
		p.Term()
	}

	return localctx
}

// IBinexprContext is an interface to support dynamic dispatch.
type IBinexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprContext differentiates from other interfaces.
	IsBinexprContext()
}

type BinexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprContext() *BinexprContext {
	var p = new(BinexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexpr
	return p
}

func (*BinexprContext) IsBinexprContext() {}

func NewBinexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprContext {
	var p = new(BinexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexpr

	return p
}

func (s *BinexprContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprContext) AllBinexprT() []IBinexprTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprTContext)(nil)).Elem())
	var tst = make([]IBinexprTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprTContext)
		}
	}

	return tst
}

func (s *BinexprContext) BinexprT(i int) IBinexprTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprTContext)
}

func (s *BinexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexpr(s)
	}
}

func (s *BinexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexpr(s)
	}
}

func (p *SyslParser) Binexpr() (localctx IBinexprContext) {
	localctx = NewBinexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SyslParserRULE_binexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Term()
	}
	p.SetState(1287)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1284)
				p.BinexprT()
			}

		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())
	}

	return localctx
}

// IE_compare_opsContext is an interface to support dynamic dispatch.
type IE_compare_opsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_compare_opsContext differentiates from other interfaces.
	IsE_compare_opsContext()
}

type E_compare_opsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_compare_opsContext() *E_compare_opsContext {
	var p = new(E_compare_opsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_compare_ops
	return p
}

func (*E_compare_opsContext) IsE_compare_opsContext() {}

func NewE_compare_opsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_compare_opsContext {
	var p = new(E_compare_opsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_compare_ops

	return p
}

func (s *E_compare_opsContext) GetParser() antlr.Parser { return s.parser }

func (s *E_compare_opsContext) E_REL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_REL, 0)
}

func (s *E_compare_opsContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *E_compare_opsContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *E_compare_opsContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *E_compare_opsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_compare_opsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_compare_opsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_compare_ops(s)
	}
}

func (s *E_compare_opsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_compare_ops(s)
	}
}

func (p *SyslParser) E_compare_ops() (localctx IE_compare_opsContext) {
	localctx = NewE_compare_opsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SyslParserRULE_e_compare_ops)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1290)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(SyslParserE_DOUBLE_EQ-77))|(1<<(SyslParserE_REL-77))|(1<<(SyslParserE_ANGLE_OPEN-77))|(1<<(SyslParserE_ANGLE_CLOSE-77)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_relContext is an interface to support dynamic dispatch.
type IExpr_relContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_relContext differentiates from other interfaces.
	IsExpr_relContext()
}

type Expr_relContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_relContext() *Expr_relContext {
	var p = new(Expr_relContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rel
	return p
}

func (*Expr_relContext) IsExpr_relContext() {}

func NewExpr_relContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_relContext {
	var p = new(Expr_relContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rel

	return p
}

func (s *Expr_relContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_relContext) AllBinexpr() []IBinexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprContext)(nil)).Elem())
	var tst = make([]IBinexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprContext)
		}
	}

	return tst
}

func (s *Expr_relContext) Binexpr(i int) IBinexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprContext)
}

func (s *Expr_relContext) AllE_compare_ops() []IE_compare_opsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem())
	var tst = make([]IE_compare_opsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IE_compare_opsContext)
		}
	}

	return tst
}

func (s *Expr_relContext) E_compare_ops(i int) IE_compare_opsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IE_compare_opsContext)
}

func (s *Expr_relContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_relContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_relContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rel(s)
	}
}

func (s *Expr_relContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rel(s)
	}
}

func (p *SyslParser) Expr_rel() (localctx IExpr_relContext) {
	localctx = NewExpr_relContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SyslParserRULE_expr_rel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.Binexpr()
	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1293)
				p.E_compare_ops()
			}
			{
				p.SetState(1294)
				p.Binexpr()
			}

		}
		p.SetState(1300)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitandContext is an interface to support dynamic dispatch.
type IExpr_bitandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitandContext differentiates from other interfaces.
	IsExpr_bitandContext()
}

type Expr_bitandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitandContext() *Expr_bitandContext {
	var p = new(Expr_bitandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitand
	return p
}

func (*Expr_bitandContext) IsExpr_bitandContext() {}

func NewExpr_bitandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitandContext {
	var p = new(Expr_bitandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitand

	return p
}

func (s *Expr_bitandContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitandContext) AllExpr_rel() []IExpr_relContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_relContext)(nil)).Elem())
	var tst = make([]IExpr_relContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_relContext)
		}
	}

	return tst
}

func (s *Expr_bitandContext) Expr_rel(i int) IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_bitandContext) AllE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AMP)
}

func (s *Expr_bitandContext) E_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AMP, i)
}

func (s *Expr_bitandContext) AllE_AND() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AND)
}

func (s *Expr_bitandContext) E_AND(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AND, i)
}

func (s *Expr_bitandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitand(s)
	}
}

func (s *Expr_bitandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitand(s)
	}
}

func (p *SyslParser) Expr_bitand() (localctx IExpr_bitandContext) {
	localctx = NewExpr_bitandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SyslParserRULE_expr_bitand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1301)
		p.Expr_rel()
	}
	p.SetState(1306)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1302)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserE_AMP || _la == SyslParserE_AND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(1303)
				p.Expr_rel()
			}

		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitxorContext is an interface to support dynamic dispatch.
type IExpr_bitxorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitxorContext differentiates from other interfaces.
	IsExpr_bitxorContext()
}

type Expr_bitxorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitxorContext() *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitxor
	return p
}

func (*Expr_bitxorContext) IsExpr_bitxorContext() {}

func NewExpr_bitxorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitxor

	return p
}

func (s *Expr_bitxorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitxorContext) AllExpr_bitand() []IExpr_bitandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem())
	var tst = make([]IExpr_bitandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitandContext)
		}
	}

	return tst
}

func (s *Expr_bitxorContext) Expr_bitand(i int) IExpr_bitandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitandContext)
}

func (s *Expr_bitxorContext) AllE_XOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_XOR)
}

func (s *Expr_bitxorContext) E_XOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_XOR, i)
}

func (s *Expr_bitxorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitxorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitxorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitxor(s)
	}
}

func (s *Expr_bitxorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitxor(s)
	}
}

func (p *SyslParser) Expr_bitxor() (localctx IExpr_bitxorContext) {
	localctx = NewExpr_bitxorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SyslParserRULE_expr_bitxor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Expr_bitand()
	}
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1310)
				p.Match(SyslParserE_XOR)
			}
			{
				p.SetState(1311)
				p.Expr_bitand()
			}

		}
		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitorContext is an interface to support dynamic dispatch.
type IExpr_bitorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitorContext differentiates from other interfaces.
	IsExpr_bitorContext()
}

type Expr_bitorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitorContext() *Expr_bitorContext {
	var p = new(Expr_bitorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitor
	return p
}

func (*Expr_bitorContext) IsExpr_bitorContext() {}

func NewExpr_bitorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitorContext {
	var p = new(Expr_bitorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitor

	return p
}

func (s *Expr_bitorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitorContext) AllExpr_bitxor() []IExpr_bitxorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem())
	var tst = make([]IExpr_bitxorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitxorContext)
		}
	}

	return tst
}

func (s *Expr_bitorContext) Expr_bitxor(i int) IExpr_bitxorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitxorContext)
}

func (s *Expr_bitorContext) AllE_BITOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BITOR)
}

func (s *Expr_bitorContext) E_BITOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BITOR, i)
}

func (s *Expr_bitorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitor(s)
	}
}

func (s *Expr_bitorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitor(s)
	}
}

func (p *SyslParser) Expr_bitor() (localctx IExpr_bitorContext) {
	localctx = NewExpr_bitorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SyslParserRULE_expr_bitor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1317)
		p.Expr_bitxor()
	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1318)
				p.Match(SyslParserE_BITOR)
			}
			{
				p.SetState(1319)
				p.Expr_bitxor()
			}

		}
		p.SetState(1324)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_andContext is an interface to support dynamic dispatch.
type IExpr_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_andContext differentiates from other interfaces.
	IsExpr_andContext()
}

type Expr_andContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_andContext() *Expr_andContext {
	var p = new(Expr_andContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_and
	return p
}

func (*Expr_andContext) IsExpr_andContext() {}

func NewExpr_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_andContext {
	var p = new(Expr_andContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_and

	return p
}

func (s *Expr_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_andContext) AllExpr_bitor() []IExpr_bitorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem())
	var tst = make([]IExpr_bitorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitorContext)
		}
	}

	return tst
}

func (s *Expr_andContext) Expr_bitor(i int) IExpr_bitorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitorContext)
}

func (s *Expr_andContext) AllE_DOUBLE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOUBLE_AMP)
}

func (s *Expr_andContext) E_DOUBLE_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_AMP, i)
}

func (s *Expr_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_and(s)
	}
}

func (s *Expr_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_and(s)
	}
}

func (p *SyslParser) Expr_and() (localctx IExpr_andContext) {
	localctx = NewExpr_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SyslParserRULE_expr_and)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1325)
		p.Expr_bitor()
	}
	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1326)
				p.Match(SyslParserE_DOUBLE_AMP)
			}
			{
				p.SetState(1327)
				p.Expr_bitor()
			}

		}
		p.SetState(1332)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_orContext is an interface to support dynamic dispatch.
type IExpr_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_orContext differentiates from other interfaces.
	IsExpr_orContext()
}

type Expr_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_orContext() *Expr_orContext {
	var p = new(Expr_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_or
	return p
}

func (*Expr_orContext) IsExpr_orContext() {}

func NewExpr_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_orContext {
	var p = new(Expr_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_or

	return p
}

func (s *Expr_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_orContext) AllExpr_and() []IExpr_andContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_andContext)(nil)).Elem())
	var tst = make([]IExpr_andContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_andContext)
		}
	}

	return tst
}

func (s *Expr_orContext) Expr_and(i int) IExpr_andContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_andContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_andContext)
}

func (s *Expr_orContext) AllE_LOGIC_OR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_LOGIC_OR)
}

func (s *Expr_orContext) E_LOGIC_OR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_LOGIC_OR, i)
}

func (s *Expr_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_or(s)
	}
}

func (s *Expr_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_or(s)
	}
}

func (p *SyslParser) Expr_or() (localctx IExpr_orContext) {
	localctx = NewExpr_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SyslParserRULE_expr_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1333)
		p.Expr_and()
	}
	p.SetState(1338)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1334)
				p.Match(SyslParserE_LOGIC_OR)
			}
			{
				p.SetState(1335)
				p.Expr_and()
			}

		}
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_but_notContext is an interface to support dynamic dispatch.
type IExpr_but_notContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_but_notContext differentiates from other interfaces.
	IsExpr_but_notContext()
}

type Expr_but_notContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_but_notContext() *Expr_but_notContext {
	var p = new(Expr_but_notContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_but_not
	return p
}

func (*Expr_but_notContext) IsExpr_but_notContext() {}

func NewExpr_but_notContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_but_notContext {
	var p = new(Expr_but_notContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_but_not

	return p
}

func (s *Expr_but_notContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_but_notContext) AllExpr_or() []IExpr_orContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_orContext)(nil)).Elem())
	var tst = make([]IExpr_orContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_orContext)
		}
	}

	return tst
}

func (s *Expr_but_notContext) Expr_or(i int) IExpr_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_orContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_orContext)
}

func (s *Expr_but_notContext) AllE_BUTNOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BUTNOT)
}

func (s *Expr_but_notContext) E_BUTNOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BUTNOT, i)
}

func (s *Expr_but_notContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_but_notContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_but_notContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_but_not(s)
	}
}

func (s *Expr_but_notContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_but_not(s)
	}
}

func (p *SyslParser) Expr_but_not() (localctx IExpr_but_notContext) {
	localctx = NewExpr_but_notContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SyslParserRULE_expr_but_not)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1341)
		p.Expr_or()
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1342)
				p.Match(SyslParserE_BUTNOT)
			}
			{
				p.SetState(1343)
				p.Expr_or()
			}

		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_coalesceContext is an interface to support dynamic dispatch.
type IExpr_coalesceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_coalesceContext differentiates from other interfaces.
	IsExpr_coalesceContext()
}

type Expr_coalesceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_coalesceContext() *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_coalesce
	return p
}

func (*Expr_coalesceContext) IsExpr_coalesceContext() {}

func NewExpr_coalesceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_coalesce

	return p
}

func (s *Expr_coalesceContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_coalesceContext) AllExpr_but_not() []IExpr_but_notContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem())
	var tst = make([]IExpr_but_notContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_but_notContext)
		}
	}

	return tst
}

func (s *Expr_coalesceContext) Expr_but_not(i int) IExpr_but_notContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_but_notContext)
}

func (s *Expr_coalesceContext) AllE_COALESCE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COALESCE)
}

func (s *Expr_coalesceContext) E_COALESCE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COALESCE, i)
}

func (s *Expr_coalesceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_coalesceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_coalesceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_coalesce(s)
	}
}

func (s *Expr_coalesceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_coalesce(s)
	}
}

func (p *SyslParser) Expr_coalesce() (localctx IExpr_coalesceContext) {
	localctx = NewExpr_coalesceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SyslParserRULE_expr_coalesce)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Expr_but_not()
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1350)
				p.Match(SyslParserE_COALESCE)
			}
			{
				p.SetState(1351)
				p.Expr_but_not()
			}

		}
		p.SetState(1356)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IIf_one_linerContext is an interface to support dynamic dispatch.
type IIf_one_linerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_one_linerContext differentiates from other interfaces.
	IsIf_one_linerContext()
}

type If_one_linerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_one_linerContext() *If_one_linerContext {
	var p = new(If_one_linerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_one_liner
	return p
}

func (*If_one_linerContext) IsIf_one_linerContext() {}

func NewIf_one_linerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_one_linerContext {
	var p = new(If_one_linerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_one_liner

	return p
}

func (s *If_one_linerContext) GetParser() antlr.Parser { return s.parser }

func (s *If_one_linerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *If_one_linerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_one_linerContext) E_THEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_THEN, 0)
}

func (s *If_one_linerContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *If_one_linerContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *If_one_linerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_one_linerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_one_linerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_one_liner(s)
	}
}

func (s *If_one_linerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_one_liner(s)
	}
}

func (p *SyslParser) If_one_liner() (localctx IIf_one_linerContext) {
	localctx = NewIf_one_linerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SyslParserRULE_if_one_liner)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1357)
		p.Expr()
	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1358)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1361)
		p.Match(SyslParserE_THEN)
	}
	{
		p.SetState(1362)
		p.Expr()
	}
	{
		p.SetState(1363)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1364)
		p.Expr()
	}

	return localctx
}

// IElse_block_stmtContext is an interface to support dynamic dispatch.
type IElse_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsElse_block_stmtContext differentiates from other interfaces.
	IsElse_block_stmtContext()
}

type Else_block_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyElse_block_stmtContext() *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_block_stmt
	return p
}

func (*Else_block_stmtContext) IsElse_block_stmtContext() {}

func NewElse_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_block_stmt

	return p
}

func (s *Else_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_block_stmtContext) Get_expr() IExprContext { return s._expr }

func (s *Else_block_stmtContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Else_block_stmtContext) GetNested() bool { return s.nested }

func (s *Else_block_stmtContext) SetNested(v bool) { s.nested = v }

func (s *Else_block_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Else_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_block_stmt(s)
	}
}

func (s *Else_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_block_stmt(s)
	}
}

func (p *SyslParser) Else_block_stmt() (localctx IElse_block_stmtContext) {
	localctx = NewElse_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SyslParserRULE_else_block_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)

		var _x = p.Expr()

		localctx.(*Else_block_stmtContext)._expr = _x
	}
	localctx.(*Else_block_stmtContext).SetNested(localctx.(*Else_block_stmtContext).Get_expr().GetNested())

	return localctx
}

// IControl_itemContext is an interface to support dynamic dispatch.
type IControl_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControl_itemContext differentiates from other interfaces.
	IsControl_itemContext()
}

type Control_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControl_itemContext() *Control_itemContext {
	var p = new(Control_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_control_item
	return p
}

func (*Control_itemContext) IsControl_itemContext() {}

func NewControl_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Control_itemContext {
	var p = new(Control_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_control_item

	return p
}

func (s *Control_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Control_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Control_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Control_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Control_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterControl_item(s)
	}
}

func (s *Control_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitControl_item(s)
	}
}

func (p *SyslParser) Control_item() (localctx IControl_itemContext) {
	localctx = NewControl_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SyslParserRULE_control_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1369)
		p.Expr()
	}

	return localctx
}

// IIf_controlsContext is an interface to support dynamic dispatch.
type IIf_controlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_controlsContext differentiates from other interfaces.
	IsIf_controlsContext()
}

type If_controlsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_controlsContext() *If_controlsContext {
	var p = new(If_controlsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_controls
	return p
}

func (*If_controlsContext) IsIf_controlsContext() {}

func NewIf_controlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_controlsContext {
	var p = new(If_controlsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_controls

	return p
}

func (s *If_controlsContext) GetParser() antlr.Parser { return s.parser }

func (s *If_controlsContext) AllControl_item() []IControl_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControl_itemContext)(nil)).Elem())
	var tst = make([]IControl_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControl_itemContext)
		}
	}

	return tst
}

func (s *If_controlsContext) Control_item(i int) IControl_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControl_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControl_itemContext)
}

func (s *If_controlsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *If_controlsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *If_controlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_controlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_controlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_controls(s)
	}
}

func (s *If_controlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_controls(s)
	}
}

func (p *SyslParser) If_controls() (localctx IIf_controlsContext) {
	localctx = NewIf_controlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SyslParserRULE_if_controls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Control_item()
	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1372)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1373)
			p.Control_item()
		}

		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICond_blockContext is an interface to support dynamic dispatch.
type ICond_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_block_stmt returns the _else_block_stmt rule contexts.
	Get_else_block_stmt() IElse_block_stmtContext

	// Set_else_block_stmt sets the _else_block_stmt rule contexts.
	Set_else_block_stmt(IElse_block_stmtContext)

	// IsCond_blockContext differentiates from other interfaces.
	IsCond_blockContext()
}

type Cond_blockContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_else_block_stmt IElse_block_stmtContext
}

func NewEmptyCond_blockContext() *Cond_blockContext {
	var p = new(Cond_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_cond_block
	return p
}

func (*Cond_blockContext) IsCond_blockContext() {}

func NewCond_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_blockContext {
	var p = new(Cond_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_cond_block

	return p
}

func (s *Cond_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_blockContext) Get_else_block_stmt() IElse_block_stmtContext { return s._else_block_stmt }

func (s *Cond_blockContext) Set_else_block_stmt(v IElse_block_stmtContext) { s._else_block_stmt = v }

func (s *Cond_blockContext) If_controls() IIf_controlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_controlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_controlsContext)
}

func (s *Cond_blockContext) E_EQ_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ_RIGHT, 0)
}

func (s *Cond_blockContext) Else_block_stmt() IElse_block_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_block_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_block_stmtContext)
}

func (s *Cond_blockContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Cond_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCond_block(s)
	}
}

func (s *Cond_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCond_block(s)
	}
}

func (p *SyslParser) Cond_block() (localctx ICond_blockContext) {
	localctx = NewCond_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SyslParserRULE_cond_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1379)
		p.If_controls()
	}
	{
		p.SetState(1380)
		p.Match(SyslParserE_EQ_RIGHT)
	}
	{
		p.SetState(1381)

		var _x = p.Else_block_stmt()

		localctx.(*Cond_blockContext)._else_block_stmt = _x
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1382)

		if !(localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$else_block_stmt.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1383)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IFinal_elseContext is an interface to support dynamic dispatch.
type IFinal_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// IsFinal_elseContext differentiates from other interfaces.
	IsFinal_elseContext()
}

type Final_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_expr  IExprContext
}

func NewEmptyFinal_elseContext() *Final_elseContext {
	var p = new(Final_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_final_else
	return p
}

func (*Final_elseContext) IsFinal_elseContext() {}

func NewFinal_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_elseContext {
	var p = new(Final_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_final_else

	return p
}

func (s *Final_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_elseContext) Get_expr() IExprContext { return s._expr }

func (s *Final_elseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Final_elseContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *Final_elseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Final_elseContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Final_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFinal_else(s)
	}
}

func (s *Final_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFinal_else(s)
	}
}

func (p *SyslParser) Final_else() (localctx IFinal_elseContext) {
	localctx = NewFinal_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SyslParserRULE_final_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1386)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1387)

		var _x = p.Expr()

		localctx.(*Final_elseContext)._expr = _x
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1388)

		if !(localctx.(*Final_elseContext).Get_expr().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$expr.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1389)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IIfvarContext is an interface to support dynamic dispatch.
type IIfvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfvarContext differentiates from other interfaces.
	IsIfvarContext()
}

type IfvarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfvarContext() *IfvarContext {
	var p = new(IfvarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ifvar
	return p
}

func (*IfvarContext) IsIfvarContext() {}

func NewIfvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfvarContext {
	var p = new(IfvarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ifvar

	return p
}

func (s *IfvarContext) GetParser() antlr.Parser { return s.parser }

func (s *IfvarContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfvarContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *IfvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIfvar(s)
	}
}

func (s *IfvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIfvar(s)
	}
}

func (p *SyslParser) Ifvar() (localctx IIfvarContext) {
	localctx = NewIfvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SyslParserRULE_ifvar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1392)
		p.Expr()
	}
	{
		p.SetState(1393)
		p.Match(SyslParserE_DOUBLE_EQ)
	}

	return localctx
}

// IIf_multiple_linesContext is an interface to support dynamic dispatch.
type IIf_multiple_linesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_multiple_linesContext differentiates from other interfaces.
	IsIf_multiple_linesContext()
}

type If_multiple_linesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_multiple_linesContext() *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_multiple_lines
	return p
}

func (*If_multiple_linesContext) IsIf_multiple_linesContext() {}

func NewIf_multiple_linesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_multiple_lines

	return p
}

func (s *If_multiple_linesContext) GetParser() antlr.Parser { return s.parser }

func (s *If_multiple_linesContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *If_multiple_linesContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *If_multiple_linesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_multiple_linesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_multiple_linesContext) Ifvar() IIfvarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfvarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfvarContext)
}

func (s *If_multiple_linesContext) AllCond_block() []ICond_blockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICond_blockContext)(nil)).Elem())
	var tst = make([]ICond_blockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICond_blockContext)
		}
	}

	return tst
}

func (s *If_multiple_linesContext) Cond_block(i int) ICond_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_blockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICond_blockContext)
}

func (s *If_multiple_linesContext) Final_else() IFinal_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_elseContext)
}

func (s *If_multiple_linesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_multiple_linesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_multiple_linesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_multiple_lines(s)
	}
}

func (s *If_multiple_linesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_multiple_lines(s)
	}
}

func (p *SyslParser) If_multiple_lines() (localctx IIf_multiple_linesContext) {
	localctx = NewIf_multiple_linesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SyslParserRULE_if_multiple_lines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
		{
			p.SetState(1395)
			p.Ifvar()
		}

	}
	{
		p.SetState(1398)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1399)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1400)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SyslParserE_WHATEVER-74))|(1<<(SyslParserE_ARROW_RIGHT-74))|(1<<(SyslParserE_SQ_OPEN-74))|(1<<(SyslParserE_EMPTY_TUPLE-74))|(1<<(SyslParserE_CURLY_OPEN-74))|(1<<(SyslParserE_NULLSAFE_DOT-74))|(1<<(SyslParserE_OPEN_PAREN-74))|(1<<(SyslParserE_PLUS-74))|(1<<(SyslParserE_MINUS-74))|(1<<(SyslParserE_QN-74))|(1<<(SyslParserE_TILDE-74))|(1<<(SyslParserE_NOT-74)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(SyslParserE_IF-112))|(1<<(SyslParserE_TRUE-112))|(1<<(SyslParserE_FALSE-112))|(1<<(SyslParserE_NULL-112))|(1<<(SyslParserE_FUNC-112))|(1<<(SyslParserE_STRING_DBL-112))|(1<<(SyslParserE_STRING_SINGLE-112))|(1<<(SyslParserE_DECIMAL-112))|(1<<(SyslParserE_DIGITS-112))|(1<<(SyslParserE_Name-112))|(1<<(SyslParserE_DOT-112)))) != 0) {
		{
			p.SetState(1401)
			p.Cond_block()
		}

		p.SetState(1404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ELSE {
		{
			p.SetState(1406)
			p.Final_else()
		}

	}
	{
		p.SetState(1409)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IExpr_if_elseContext is an interface to support dynamic dispatch.
type IExpr_if_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_if_elseContext differentiates from other interfaces.
	IsExpr_if_elseContext()
}

type Expr_if_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
}

func NewEmptyExpr_if_elseContext() *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_if_else
	return p
}

func (*Expr_if_elseContext) IsExpr_if_elseContext() {}

func NewExpr_if_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_if_else

	return p
}

func (s *Expr_if_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_if_elseContext) GetNested() bool { return s.nested }

func (s *Expr_if_elseContext) SetNested(v bool) { s.nested = v }

func (s *Expr_if_elseContext) E_IF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_IF, 0)
}

func (s *Expr_if_elseContext) If_one_liner() IIf_one_linerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_one_linerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_one_linerContext)
}

func (s *Expr_if_elseContext) If_multiple_lines() IIf_multiple_linesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_multiple_linesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_multiple_linesContext)
}

func (s *Expr_if_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_if_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_if_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_if_else(s)
	}
}

func (s *Expr_if_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_if_else(s)
	}
}

func (p *SyslParser) Expr_if_else() (localctx IExpr_if_elseContext) {
	localctx = NewExpr_if_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SyslParserRULE_expr_if_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		p.Match(SyslParserE_IF)
	}
	p.SetState(1416)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1412)
			p.If_one_liner()
		}

	case 2:
		{
			p.SetState(1413)
			p.If_multiple_lines()
		}
		localctx.(*Expr_if_elseContext).SetNested(true)

	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_if_else returns the _expr_if_else rule contexts.
	Get_expr_if_else() IExpr_if_elseContext

	// Set_expr_if_else sets the _expr_if_else rule contexts.
	Set_expr_if_else(IExpr_if_elseContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	nested        bool
	_expr_if_else IExpr_if_elseContext
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Get_expr_if_else() IExpr_if_elseContext { return s._expr_if_else }

func (s *ExprContext) Set_expr_if_else(v IExpr_if_elseContext) { s._expr_if_else = v }

func (s *ExprContext) GetNested() bool { return s.nested }

func (s *ExprContext) SetNested(v bool) { s.nested = v }

func (s *ExprContext) Expr_if_else() IExpr_if_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_if_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_if_elseContext)
}

func (s *ExprContext) Expr_coalesce() IExpr_coalesceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_coalesceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_coalesceContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SyslParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SyslParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1422)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_IF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1418)

			var _x = p.Expr_if_else()

			localctx.(*ExprContext)._expr_if_else = _x
		}
		localctx.(*ExprContext).SetNested(localctx.(*ExprContext).Get_expr_if_else().GetNested())

	case SyslParserNativeDataTypes, SyslParserE_WHATEVER, SyslParserE_ARROW_RIGHT, SyslParserE_SQ_OPEN, SyslParserE_EMPTY_TUPLE, SyslParserE_CURLY_OPEN, SyslParserE_NULLSAFE_DOT, SyslParserE_OPEN_PAREN, SyslParserE_PLUS, SyslParserE_MINUS, SyslParserE_QN, SyslParserE_TILDE, SyslParserE_NOT, SyslParserE_TRUE, SyslParserE_FALSE, SyslParserE_NULL, SyslParserE_FUNC, SyslParserE_STRING_DBL, SyslParserE_STRING_SINGLE, SyslParserE_DECIMAL, SyslParserE_DIGITS, SyslParserE_Name, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1421)
			p.Expr_coalesce()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_assignContext is an interface to support dynamic dispatch.
type IExpr_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_assignContext differentiates from other interfaces.
	IsExpr_assignContext()
}

type Expr_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyExpr_assignContext() *Expr_assignContext {
	var p = new(Expr_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_assign
	return p
}

func (*Expr_assignContext) IsExpr_assignContext() {}

func NewExpr_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_assignContext {
	var p = new(Expr_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_assign

	return p
}

func (s *Expr_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_assignContext) Get_expr() IExprContext { return s._expr }

func (s *Expr_assignContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Expr_assignContext) GetNested() bool { return s.nested }

func (s *Expr_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_assignContext) E_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ, 0)
}

func (s *Expr_assignContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_assignContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_assign(s)
	}
}

func (s *Expr_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_assign(s)
	}
}

func (p *SyslParser) Expr_assign() (localctx IExpr_assignContext) {
	localctx = NewExpr_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SyslParserRULE_expr_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1424)
		p.Match(SyslParserE_EQ)
	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1425)

			var _x = p.Expr()

			localctx.(*Expr_assignContext)._expr = _x
		}
		localctx.(*Expr_assignContext).SetNested(localctx.(*Expr_assignContext).Get_expr().GetNested())

	case 2:
		{
			p.SetState(1428)
			p.Transform()
		}
		localctx.(*Expr_assignContext).SetNested(true)

	}

	return localctx
}

// IExpr_simple_assignContext is an interface to support dynamic dispatch.
type IExpr_simple_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_simple_assignContext differentiates from other interfaces.
	IsExpr_simple_assignContext()
}

type Expr_simple_assignContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_simple_assignContext() *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_simple_assign
	return p
}

func (*Expr_simple_assignContext) IsExpr_simple_assignContext() {}

func NewExpr_simple_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_simple_assign

	return p
}

func (s *Expr_simple_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_simple_assignContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_simple_assignContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_simple_assignContext) GetNested() bool { return s.nested }

func (s *Expr_simple_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_simple_assignContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_simple_assignContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_simple_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_simple_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_simple_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_simple_assign(s)
	}
}

func (s *Expr_simple_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_simple_assign(s)
	}
}

func (p *SyslParser) Expr_simple_assign() (localctx IExpr_simple_assignContext) {
	localctx = NewExpr_simple_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SyslParserRULE_expr_simple_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1433)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1434)

		var _x = p.Expr_assign()

		localctx.(*Expr_simple_assignContext)._expr_assign = _x
	}
	localctx.(*Expr_simple_assignContext).SetNested(localctx.(*Expr_simple_assignContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_let_statementContext is an interface to support dynamic dispatch.
type IExpr_let_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_let_statementContext differentiates from other interfaces.
	IsExpr_let_statementContext()
}

type Expr_let_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_let_statementContext() *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_let_statement
	return p
}

func (*Expr_let_statementContext) IsExpr_let_statementContext() {}

func NewExpr_let_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_let_statement

	return p
}

func (s *Expr_let_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_let_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_let_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_let_statementContext) GetNested() bool { return s.nested }

func (s *Expr_let_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_let_statementContext) E_LET() antlr.TerminalNode {
	return s.GetToken(SyslParserE_LET, 0)
}

func (s *Expr_let_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_let_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_let_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_let_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_let_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_let_statement(s)
	}
}

func (s *Expr_let_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_let_statement(s)
	}
}

func (p *SyslParser) Expr_let_statement() (localctx IExpr_let_statementContext) {
	localctx = NewExpr_let_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SyslParserRULE_expr_let_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1437)
		p.Match(SyslParserE_LET)
	}
	{
		p.SetState(1438)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1439)

		var _x = p.Expr_assign()

		localctx.(*Expr_let_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_let_statementContext).SetNested(localctx.(*Expr_let_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_table_of_statementContext is an interface to support dynamic dispatch.
type IExpr_table_of_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_table_of_statementContext differentiates from other interfaces.
	IsExpr_table_of_statementContext()
}

type Expr_table_of_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_table_of_statementContext() *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_statement
	return p
}

func (*Expr_table_of_statementContext) IsExpr_table_of_statementContext() {}

func NewExpr_table_of_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_statement

	return p
}

func (s *Expr_table_of_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_table_of_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_table_of_statementContext) GetNested() bool { return s.nested }

func (s *Expr_table_of_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_table_of_statementContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_table_of_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_statement(s)
	}
}

func (s *Expr_table_of_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_statement(s)
	}
}

func (p *SyslParser) Expr_table_of_statement() (localctx IExpr_table_of_statementContext) {
	localctx = NewExpr_table_of_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SyslParserRULE_expr_table_of_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1442)
		p.Match(SyslParserE_TABLE_OF)
	}
	{
		p.SetState(1443)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1444)

		var _x = p.Expr_assign()

		localctx.(*Expr_table_of_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_table_of_statementContext).SetNested(localctx.(*Expr_table_of_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_dot_assignContext is an interface to support dynamic dispatch.
type IExpr_dot_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_dot_assignContext differentiates from other interfaces.
	IsExpr_dot_assignContext()
}

type Expr_dot_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_assignContext() *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_dot_assign
	return p
}

func (*Expr_dot_assignContext) IsExpr_dot_assignContext() {}

func NewExpr_dot_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_dot_assign

	return p
}

func (s *Expr_dot_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_assignContext) E_DOT_NAME_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT_NAME_NL, 0)
}

func (s *Expr_dot_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_dot_assign(s)
	}
}

func (s *Expr_dot_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_dot_assign(s)
	}
}

func (p *SyslParser) Expr_dot_assign() (localctx IExpr_dot_assignContext) {
	localctx = NewExpr_dot_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SyslParserRULE_expr_dot_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1447)
		p.Match(SyslParserE_DOT_NAME_NL)
	}

	return localctx
}

// IExpr_statement_no_nlContext is an interface to support dynamic dispatch.
type IExpr_statement_no_nlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_statement_no_nlContext differentiates from other interfaces.
	IsExpr_statement_no_nlContext()
}

type Expr_statement_no_nlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_statement_no_nlContext() *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl
	return p
}

func (*Expr_statement_no_nlContext) IsExpr_statement_no_nlContext() {}

func NewExpr_statement_no_nlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl

	return p
}

func (s *Expr_statement_no_nlContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statement_no_nlContext) Expr_dot_assign() IExpr_dot_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_dot_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_assignContext)
}

func (s *Expr_statement_no_nlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statement_no_nlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statement_no_nlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement_no_nl(s)
	}
}

func (s *Expr_statement_no_nlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement_no_nl(s)
	}
}

func (p *SyslParser) Expr_statement_no_nl() (localctx IExpr_statement_no_nlContext) {
	localctx = NewExpr_statement_no_nlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SyslParserRULE_expr_statement_no_nl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.Expr_dot_assign()
	}

	return localctx
}

// IExpr_statementContext is an interface to support dynamic dispatch.
type IExpr_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_let_statement returns the _expr_let_statement rule contexts.
	Get_expr_let_statement() IExpr_let_statementContext

	// Get_expr_table_of_statement returns the _expr_table_of_statement rule contexts.
	Get_expr_table_of_statement() IExpr_table_of_statementContext

	// Get_expr_simple_assign returns the _expr_simple_assign rule contexts.
	Get_expr_simple_assign() IExpr_simple_assignContext

	// Set_expr_let_statement sets the _expr_let_statement rule contexts.
	Set_expr_let_statement(IExpr_let_statementContext)

	// Set_expr_table_of_statement sets the _expr_table_of_statement rule contexts.
	Set_expr_table_of_statement(IExpr_table_of_statementContext)

	// Set_expr_simple_assign sets the _expr_simple_assign rule contexts.
	Set_expr_simple_assign(IExpr_simple_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_statementContext differentiates from other interfaces.
	IsExpr_statementContext()
}

type Expr_statementContext struct {
	*antlr.BaseParserRuleContext
	parser                   antlr.Parser
	nested                   bool
	_expr_let_statement      IExpr_let_statementContext
	_expr_table_of_statement IExpr_table_of_statementContext
	_expr_simple_assign      IExpr_simple_assignContext
}

func NewEmptyExpr_statementContext() *Expr_statementContext {
	var p = new(Expr_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement
	return p
}

func (*Expr_statementContext) IsExpr_statementContext() {}

func NewExpr_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statementContext {
	var p = new(Expr_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement

	return p
}

func (s *Expr_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statementContext) Get_expr_let_statement() IExpr_let_statementContext {
	return s._expr_let_statement
}

func (s *Expr_statementContext) Get_expr_table_of_statement() IExpr_table_of_statementContext {
	return s._expr_table_of_statement
}

func (s *Expr_statementContext) Get_expr_simple_assign() IExpr_simple_assignContext {
	return s._expr_simple_assign
}

func (s *Expr_statementContext) Set_expr_let_statement(v IExpr_let_statementContext) {
	s._expr_let_statement = v
}

func (s *Expr_statementContext) Set_expr_table_of_statement(v IExpr_table_of_statementContext) {
	s._expr_table_of_statement = v
}

func (s *Expr_statementContext) Set_expr_simple_assign(v IExpr_simple_assignContext) {
	s._expr_simple_assign = v
}

func (s *Expr_statementContext) GetNested() bool { return s.nested }

func (s *Expr_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_statementContext) Expr_let_statement() IExpr_let_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_let_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_let_statementContext)
}

func (s *Expr_statementContext) Expr_table_of_statement() IExpr_table_of_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_statementContext)
}

func (s *Expr_statementContext) Expr_simple_assign() IExpr_simple_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_simple_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_simple_assignContext)
}

func (s *Expr_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement(s)
	}
}

func (s *Expr_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement(s)
	}
}

func (p *SyslParser) Expr_statement() (localctx IExpr_statementContext) {
	localctx = NewExpr_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SyslParserRULE_expr_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1460)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_LET:
		{
			p.SetState(1451)

			var _x = p.Expr_let_statement()

			localctx.(*Expr_statementContext)._expr_let_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_let_statement().GetNested())

	case SyslParserE_TABLE_OF:
		{
			p.SetState(1454)

			var _x = p.Expr_table_of_statement()

			localctx.(*Expr_statementContext)._expr_table_of_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_table_of_statement().GetNested())

	case SyslParserE_Name:
		{
			p.SetState(1457)

			var _x = p.Expr_simple_assign()

			localctx.(*Expr_statementContext)._expr_simple_assign = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_simple_assign().GetNested())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1462)

		if !(localctx.(*Expr_statementContext).nested == true) {
			panic(antlr.NewFailedPredicateException(p, "$nested == true", ""))
		}

	case 2:
		{
			p.SetState(1463)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IExpr_inject_stmtContext is an interface to support dynamic dispatch.
type IExpr_inject_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_inject_stmtContext differentiates from other interfaces.
	IsExpr_inject_stmtContext()
}

type Expr_inject_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_inject_stmtContext() *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_inject_stmt
	return p
}

func (*Expr_inject_stmtContext) IsExpr_inject_stmtContext() {}

func NewExpr_inject_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_inject_stmt

	return p
}

func (s *Expr_inject_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_inject_stmtContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_inject_stmtContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_inject_stmtContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *Expr_inject_stmtContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_inject_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_inject_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_inject_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_inject_stmt(s)
	}
}

func (s *Expr_inject_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_inject_stmt(s)
	}
}

func (p *SyslParser) Expr_inject_stmt() (localctx IExpr_inject_stmtContext) {
	localctx = NewExpr_inject_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SyslParserRULE_expr_inject_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1466)
		p.Expr_func()
	}
	{
		p.SetState(1467)
		p.Match(SyslParserE_DOT)
	}
	{
		p.SetState(1468)
		p.Match(SyslParserE_STAR)
	}
	{
		p.SetState(1469)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr_statement_no_nl() IExpr_statement_no_nlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statement_no_nlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statement_no_nlContext)
}

func (s *Expr_stmtContext) Expr_statement() IExpr_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statementContext)
}

func (s *Expr_stmtContext) Expr_inject_stmt() IExpr_inject_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_inject_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_inject_stmtContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *SyslParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SyslParserRULE_expr_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1474)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1471)
			p.Expr_statement_no_nl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1472)
			p.Expr_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1473)
			p.Expr_inject_stmt()
		}

	}

	return localctx
}

// ITransform_return_typeContext is an interface to support dynamic dispatch.
type ITransform_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_return_typeContext differentiates from other interfaces.
	IsTransform_return_typeContext()
}

type Transform_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_return_typeContext() *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_return_type
	return p
}

func (*Transform_return_typeContext) IsTransform_return_typeContext() {}

func NewTransform_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_return_type

	return p
}

func (s *Transform_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_return_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Transform_return_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Transform_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Transform_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_return_type(s)
	}
}

func (s *Transform_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_return_type(s)
	}
}

func (p *SyslParser) Transform_return_type() (localctx ITransform_return_typeContext) {
	localctx = NewTransform_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SyslParserRULE_transform_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1479)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1476)
			p.Set_of()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1477)
			p.Sequence_of()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1478)
			p.View_type_spec()
		}

	}

	return localctx
}

// IView_return_typeContext is an interface to support dynamic dispatch.
type IView_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_return_typeContext differentiates from other interfaces.
	IsView_return_typeContext()
}

type View_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_return_typeContext() *View_return_typeContext {
	var p = new(View_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_return_type
	return p
}

func (*View_return_typeContext) IsView_return_typeContext() {}

func NewView_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_return_typeContext {
	var p = new(View_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_return_type

	return p
}

func (s *View_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *View_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_return_type(s)
	}
}

func (s *View_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_return_type(s)
	}
}

func (p *SyslParser) View_return_type() (localctx IView_return_typeContext) {
	localctx = NewView_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SyslParserRULE_view_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1481)
		p.View_type_spec()
	}

	return localctx
}

// ITransform_scope_varContext is an interface to support dynamic dispatch.
type ITransform_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_scope_varContext differentiates from other interfaces.
	IsTransform_scope_varContext()
}

type Transform_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_scope_varContext() *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_scope_var
	return p
}

func (*Transform_scope_varContext) IsTransform_scope_varContext() {}

func NewTransform_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_scope_var

	return p
}

func (s *Transform_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Transform_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_scope_var(s)
	}
}

func (s *Transform_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_scope_var(s)
	}
}

func (p *SyslParser) Transform_scope_var() (localctx ITransform_scope_varContext) {
	localctx = NewTransform_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SyslParserRULE_transform_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// ITransform_argContext is an interface to support dynamic dispatch.
type ITransform_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_argContext differentiates from other interfaces.
	IsTransform_argContext()
}

type Transform_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_argContext() *Transform_argContext {
	var p = new(Transform_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_arg
	return p
}

func (*Transform_argContext) IsTransform_argContext() {}

func NewTransform_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_argContext {
	var p = new(Transform_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_arg

	return p
}

func (s *Transform_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Transform_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_arg(s)
	}
}

func (s *Transform_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_arg(s)
	}
}

func (p *SyslParser) Transform_arg() (localctx ITransform_argContext) {
	localctx = NewTransform_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SyslParserRULE_transform_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1485)
		p.Expr()
	}

	return localctx
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform
	return p
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *TransformContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *TransformContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *TransformContext) AllE_NL() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_NL)
}

func (s *TransformContext) E_NL(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, i)
}

func (s *TransformContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *TransformContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *TransformContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *TransformContext) Transform_arg() ITransform_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_argContext)
}

func (s *TransformContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *TransformContext) Transform_return_type() ITransform_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_return_typeContext)
}

func (s *TransformContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *TransformContext) Transform_scope_var() ITransform_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_scope_varContext)
}

func (s *TransformContext) AllExpr_stmt() []IExpr_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem())
	var tst = make([]IExpr_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_stmtContext)
		}
	}

	return tst
}

func (s *TransformContext) Expr_stmt(i int) IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform(s)
	}
}

func (s *TransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform(s)
	}
}

func (p *SyslParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SyslParserRULE_transform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1487)
			p.Transform_arg()
		}

	}
	{
		p.SetState(1490)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1491)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1492)
			p.Transform_return_type()
		}
		{
			p.SetState(1493)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1497)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_Name {
		{
			p.SetState(1498)
			p.Transform_scope_var()
		}

	}
	{
		p.SetState(1501)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1502)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1503)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || _la == SyslParserE_TABLE_OF || _la == SyslParserE_LET || (((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(SyslParserE_FUNC-133))|(1<<(SyslParserE_DOT_NAME_NL-133))|(1<<(SyslParserE_Name-133)))) != 0) {
		{
			p.SetState(1504)
			p.Expr_stmt()
		}

		p.SetState(1507)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1509)
		p.Match(SyslParserDEDENT)
	}
	{
		p.SetState(1510)
		p.Match(SyslParserE_CLOSE_PAREN)
	}
	{
		p.SetState(1511)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_blockContext is an interface to support dynamic dispatch.
type IExpr_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_blockContext differentiates from other interfaces.
	IsExpr_blockContext()
}

type Expr_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_blockContext() *Expr_blockContext {
	var p = new(Expr_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_block
	return p
}

func (*Expr_blockContext) IsExpr_blockContext() {}

func NewExpr_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_blockContext {
	var p = new(Expr_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_block

	return p
}

func (s *Expr_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_blockContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Expr_blockContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_blockContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Expr_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_block(s)
	}
}

func (s *Expr_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_block(s)
	}
}

func (p *SyslParser) Expr_block() (localctx IExpr_blockContext) {
	localctx = NewExpr_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SyslParserRULE_expr_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1513)
		p.Match(SyslParserINDENT)
	}
	{
		p.SetState(1514)
		p.Transform()
	}
	{
		p.SetState(1515)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IView_paramContext is an interface to support dynamic dispatch.
type IView_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramContext differentiates from other interfaces.
	IsView_paramContext()
}

type View_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramContext() *View_paramContext {
	var p = new(View_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_param
	return p
}

func (*View_paramContext) IsView_paramContext() {}

func NewView_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramContext {
	var p = new(View_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_param

	return p
}

func (s *View_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *View_paramContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *View_paramContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_param(s)
	}
}

func (s *View_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_param(s)
	}
}

func (p *SyslParser) View_param() (localctx IView_paramContext) {
	localctx = NewView_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SyslParserRULE_view_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Name_str()
	}
	{
		p.SetState(1518)
		p.Match(SyslParserLESS_COLON)
	}
	{
		p.SetState(1519)
		p.View_type_spec()
	}

	return localctx
}

// IView_paramsContext is an interface to support dynamic dispatch.
type IView_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramsContext differentiates from other interfaces.
	IsView_paramsContext()
}

type View_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramsContext() *View_paramsContext {
	var p = new(View_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_params
	return p
}

func (*View_paramsContext) IsView_paramsContext() {}

func NewView_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramsContext {
	var p = new(View_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_params

	return p
}

func (s *View_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramsContext) AllView_param() []IView_paramContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IView_paramContext)(nil)).Elem())
	var tst = make([]IView_paramContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IView_paramContext)
		}
	}

	return tst
}

func (s *View_paramsContext) View_param(i int) IView_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IView_paramContext)
}

func (s *View_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *View_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *View_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_params(s)
	}
}

func (s *View_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_params(s)
	}
}

func (p *SyslParser) View_params() (localctx IView_paramsContext) {
	localctx = NewView_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SyslParserRULE_view_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.View_param()
	}
	p.SetState(1526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(1522)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(1523)
			p.View_param()
		}

		p.SetState(1528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAbstract_viewContext is an interface to support dynamic dispatch.
type IAbstract_viewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_viewContext differentiates from other interfaces.
	IsAbstract_viewContext()
}

type Abstract_viewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_viewContext() *Abstract_viewContext {
	var p = new(Abstract_viewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_abstract_view
	return p
}

func (*Abstract_viewContext) IsAbstract_viewContext() {}

func NewAbstract_viewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_viewContext {
	var p = new(Abstract_viewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_abstract_view

	return p
}

func (s *Abstract_viewContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_viewContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(SyslParserABSTRACT, 0)
}

func (s *Abstract_viewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_viewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_viewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAbstract_view(s)
	}
}

func (s *Abstract_viewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAbstract_view(s)
	}
}

func (p *SyslParser) Abstract_view() (localctx IAbstract_viewContext) {
	localctx = NewAbstract_viewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SyslParserRULE_abstract_view)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.Match(SyslParserABSTRACT)
	}

	return localctx
}

// IViewContext is an interface to support dynamic dispatch.
type IViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbstractView returns the abstractView attribute.
	GetAbstractView() bool

	// SetAbstractView sets the abstractView attribute.
	SetAbstractView(bool)

	// IsViewContext differentiates from other interfaces.
	IsViewContext()
}

type ViewContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	abstractView bool
}

func NewEmptyViewContext() *ViewContext {
	var p = new(ViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view
	return p
}

func (*ViewContext) IsViewContext() {}

func NewViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewContext {
	var p = new(ViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view

	return p
}

func (s *ViewContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewContext) GetAbstractView() bool { return s.abstractView }

func (s *ViewContext) SetAbstractView(v bool) { s.abstractView = v }

func (s *ViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SyslParserVIEW, 0)
}

func (s *ViewContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ViewContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ViewContext) View_params() IView_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_paramsContext)
}

func (s *ViewContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ViewContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ViewContext) Expr_block() IExpr_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_blockContext)
}

func (s *ViewContext) Abstract_view() IAbstract_viewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_viewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_viewContext)
}

func (s *ViewContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *ViewContext) View_return_type() IView_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_return_typeContext)
}

func (s *ViewContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *ViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView(s)
	}
}

func (s *ViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView(s)
	}
}

func (p *SyslParser) View() (localctx IViewContext) {
	localctx = NewViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SyslParserRULE_view)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1531)
		p.Match(SyslParserVIEW)
	}
	{
		p.SetState(1532)
		p.Name_str()
	}
	{
		p.SetState(1533)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(1534)
		p.View_params()
	}
	{
		p.SetState(1535)
		p.Match(SyslParserCLOSE_PAREN)
	}
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserARROW_RIGHT {
		{
			p.SetState(1536)
			p.Match(SyslParserARROW_RIGHT)
		}
		{
			p.SetState(1537)
			p.View_return_type()
		}

	}
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserCOLON, SyslParserSQ_OPEN:
		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(1540)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(1543)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(1544)
			p.Expr_block()
		}

	case SyslParserABSTRACT:
		{
			p.SetState(1545)
			p.Abstract_view()
		}
		localctx.(*ViewContext).SetAbstractView(true)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(SyslParserALIAS, 0)
}

func (s *AliasContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *AliasContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *AliasContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *AliasContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AliasContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AliasContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *AliasContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *AliasContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AliasContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *SyslParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SyslParserRULE_alias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.Match(SyslParserALIAS)
	}
	{
		p.SetState(1551)
		p.Name_str()
	}
	p.SetState(1553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1552)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1555)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserAT, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
		p.SetState(1559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserAT {
			{
				p.SetState(1556)
				p.Annotation()
			}

			p.SetState(1561)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1564)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(1562)
				p.Types()
			}

		case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
			{
				p.SetState(1563)
				p.Collection_type()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SyslParserINDENT:
		{
			p.SetState(1566)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserAT {
			{
				p.SetState(1567)
				p.Annotation()
			}

			p.SetState(1572)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1575)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(1573)
				p.Types()
			}

		case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
			{
				p.SetState(1574)
				p.Collection_type()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1577)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IApp_declContext is an interface to support dynamic dispatch.
type IApp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_view returns the _view rule contexts.
	Get_view() IViewContext

	// Set_view sets the _view rule contexts.
	Set_view(IViewContext)

	// GetCheck returns the check attribute.
	GetCheck() bool

	// SetCheck sets the check attribute.
	SetCheck(bool)

	// IsApp_declContext differentiates from other interfaces.
	IsApp_declContext()
}

type App_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	check  bool
	_view  IViewContext
}

func NewEmptyApp_declContext() *App_declContext {
	var p = new(App_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_decl
	return p
}

func (*App_declContext) IsApp_declContext() {}

func NewApp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_declContext {
	var p = new(App_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_decl

	return p
}

func (s *App_declContext) GetParser() antlr.Parser { return s.parser }

func (s *App_declContext) Get_view() IViewContext { return s._view }

func (s *App_declContext) Set_view(v IViewContext) { s._view = v }

func (s *App_declContext) GetCheck() bool { return s.check }

func (s *App_declContext) SetCheck(v bool) { s.check = v }

func (s *App_declContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *App_declContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *App_declContext) AllAlias() []IAliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAliasContext)(nil)).Elem())
	var tst = make([]IAliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAliasContext)
		}
	}

	return tst
}

func (s *App_declContext) Alias(i int) IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *App_declContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *App_declContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *App_declContext) AllCollector() []ICollectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollectorContext)(nil)).Elem())
	var tst = make([]ICollectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollectorContext)
		}
	}

	return tst
}

func (s *App_declContext) Collector(i int) ICollectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollectorContext)
}

func (s *App_declContext) AllEvent() []IEventContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEventContext)(nil)).Elem())
	var tst = make([]IEventContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEventContext)
		}
	}

	return tst
}

func (s *App_declContext) Event(i int) IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *App_declContext) AllFacade() []IFacadeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFacadeContext)(nil)).Elem())
	var tst = make([]IFacadeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFacadeContext)
		}
	}

	return tst
}

func (s *App_declContext) Facade(i int) IFacadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFacadeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFacadeContext)
}

func (s *App_declContext) AllMixin() []IMixinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMixinContext)(nil)).Elem())
	var tst = make([]IMixinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMixinContext)
		}
	}

	return tst
}

func (s *App_declContext) Mixin(i int) IMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMixinContext)
}

func (s *App_declContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *App_declContext) AllSimple_endpoint() []ISimple_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem())
	var tst = make([]ISimple_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Simple_endpoint(i int) ISimple_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_endpointContext)
}

func (s *App_declContext) AllSubscribe() []ISubscribeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscribeContext)(nil)).Elem())
	var tst = make([]ISubscribeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscribeContext)
		}
	}

	return tst
}

func (s *App_declContext) Subscribe(i int) ISubscribeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscribeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscribeContext)
}

func (s *App_declContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *App_declContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *App_declContext) AllUnion() []IUnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionContext)(nil)).Elem())
	var tst = make([]IUnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionContext)
		}
	}

	return tst
}

func (s *App_declContext) Union(i int) IUnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *App_declContext) AllView() []IViewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewContext)(nil)).Elem())
	var tst = make([]IViewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewContext)
		}
	}

	return tst
}

func (s *App_declContext) View(i int) IViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewContext)
}

func (s *App_declContext) AllTable() []ITableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableContext)(nil)).Elem())
	var tst = make([]ITableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableContext)
		}
	}

	return tst
}

func (s *App_declContext) Table(i int) ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *App_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_decl(s)
	}
}

func (s *App_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_decl(s)
	}
}

func (p *SyslParser) App_decl() (localctx IApp_declContext) {
	localctx = NewApp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SyslParserRULE_app_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1581)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1597)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1582)
					p.Alias()
				}

			case 2:
				{
					p.SetState(1583)
					p.Annotation()
				}

			case 3:
				{
					p.SetState(1584)
					p.Collector()
				}

			case 4:
				{
					p.SetState(1585)
					p.Event()
				}

			case 5:
				{
					p.SetState(1586)
					p.Facade()
				}

			case 6:
				{
					p.SetState(1587)
					p.Mixin()
				}

			case 7:
				{
					p.SetState(1588)
					p.Rest_endpoint()
				}

			case 8:
				{
					p.SetState(1589)
					p.Simple_endpoint()
				}

			case 9:
				{
					p.SetState(1590)
					p.Subscribe()
				}

			case 10:
				{
					p.SetState(1591)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case 11:
				{
					p.SetState(1592)
					p.Union()
				}

			case 12:
				{
					p.SetState(1593)

					var _x = p.View()

					localctx.(*App_declContext)._view = _x
				}
				localctx.(*App_declContext).SetCheck(localctx.(*App_declContext).Get_view().GetAbstractView())

			case 13:
				{
					p.SetState(1596)
					p.Table()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
	}
	p.SetState(1603)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1601)

		if !(localctx.(*App_declContext).check) {
			panic(antlr.NewFailedPredicateException(p, "$check", ""))
		}

	case 2:
		{
			p.SetState(1602)
			p.Match(SyslParserDEDENT)
		}

	}

	return localctx
}

// IApplicationContext is an interface to support dynamic dispatch.
type IApplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApplicationContext differentiates from other interfaces.
	IsApplicationContext()
}

type ApplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplicationContext() *ApplicationContext {
	var p = new(ApplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_application
	return p
}

func (*ApplicationContext) IsApplicationContext() {}

func NewApplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplicationContext {
	var p = new(ApplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_application

	return p
}

func (s *ApplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplicationContext) Name_with_attribs() IName_with_attribsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_with_attribsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_with_attribsContext)
}

func (s *ApplicationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ApplicationContext) App_decl() IApp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_declContext)
}

func (s *ApplicationContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *ApplicationContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *ApplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApplication(s)
	}
}

func (s *ApplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApplication(s)
	}
}

func (p *SyslParser) Application() (localctx IApplicationContext) {
	localctx = NewApplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SyslParserRULE_application)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(1605)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(1610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1611)
		p.Name_with_attribs()
	}
	{
		p.SetState(1612)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1613)
		p.App_decl()
	}

	return localctx
}

// IImport_modeContext is an interface to support dynamic dispatch.
type IImport_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_modeContext differentiates from other interfaces.
	IsImport_modeContext()
}

type Import_modeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_modeContext() *Import_modeContext {
	var p = new(Import_modeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_mode
	return p
}

func (*Import_modeContext) IsImport_modeContext() {}

func NewImport_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_modeContext {
	var p = new(Import_modeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_mode

	return p
}

func (s *Import_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_modeContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *Import_modeContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Import_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_mode(s)
	}
}

func (s *Import_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_mode(s)
	}
}

func (p *SyslParser) Import_mode() (localctx IImport_modeContext) {
	localctx = NewImport_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SyslParserRULE_import_mode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(1616)
		p.Match(SyslParserName)
	}

	return localctx
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT, 0)
}

func (s *Import_stmtContext) IMPORT_PATH() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT_PATH, 0)
}

func (s *Import_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(SyslParserNEWLINE, 0)
}

func (s *Import_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(SyslParserAS, 0)
}

func (s *Import_stmtContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Import_stmtContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Import_stmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWS)
}

func (s *Import_stmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWS, i)
}

func (s *Import_stmtContext) Import_mode() IImport_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_modeContext)
}

func (s *Import_stmtContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Import_stmtContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Import_stmtContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *Import_stmtContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *SyslParser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SyslParserRULE_import_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1618)
		p.Match(SyslParserIMPORT)
	}
	{
		p.SetState(1619)
		p.Match(SyslParserIMPORT_PATH)
	}
	p.SetState(1629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserAS {
		{
			p.SetState(1620)
			p.Match(SyslParserAS)
		}
		{
			p.SetState(1621)
			p.Match(SyslParserName)
		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserDOT {
			{
				p.SetState(1622)
				p.Match(SyslParserDOT)
			}
			{
				p.SetState(1623)
				p.Match(SyslParserName)
			}

			p.SetState(1628)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserWS {
		{
			p.SetState(1631)
			p.Match(SyslParserWS)
		}

		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserTILDE {
		{
			p.SetState(1637)
			p.Import_mode()
		}

	}
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserIMPORT, SyslParserSYSL_COMMENT, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1640)
					p.Match(SyslParserSYSL_COMMENT)
				}

			}
			p.SetState(1645)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())
		}

	case SyslParserNEWLINE:
		{
			p.SetState(1646)
			p.Match(SyslParserNEWLINE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImports_declContext is an interface to support dynamic dispatch.
type IImports_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImports_declContext differentiates from other interfaces.
	IsImports_declContext()
}

type Imports_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImports_declContext() *Imports_declContext {
	var p = new(Imports_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_imports_decl
	return p
}

func (*Imports_declContext) IsImports_declContext() {}

func NewImports_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imports_declContext {
	var p = new(Imports_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_imports_decl

	return p
}

func (s *Imports_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Imports_declContext) AllImport_stmt() []IImport_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem())
	var tst = make([]IImport_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_stmtContext)
		}
	}

	return tst
}

func (s *Imports_declContext) Import_stmt(i int) IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Imports_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imports_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imports_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImports_decl(s)
	}
}

func (s *Imports_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImports_decl(s)
	}
}

func (p *SyslParser) Imports_decl() (localctx IImports_declContext) {
	localctx = NewImports_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SyslParserRULE_imports_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserIMPORT {
		{
			p.SetState(1649)
			p.Import_stmt()
		}

		p.SetState(1652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISysl_fileContext is an interface to support dynamic dispatch.
type ISysl_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSysl_fileContext differentiates from other interfaces.
	IsSysl_fileContext()
}

type Sysl_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysl_fileContext() *Sysl_fileContext {
	var p = new(Sysl_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sysl_file
	return p
}

func (*Sysl_fileContext) IsSysl_fileContext() {}

func NewSysl_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sysl_fileContext {
	var p = new(Sysl_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sysl_file

	return p
}

func (s *Sysl_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Sysl_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(SyslParserEOF, 0)
}

func (s *Sysl_fileContext) Imports_decl() IImports_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImports_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImports_declContext)
}

func (s *Sysl_fileContext) AllApplication() []IApplicationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApplicationContext)(nil)).Elem())
	var tst = make([]IApplicationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApplicationContext)
		}
	}

	return tst
}

func (s *Sysl_fileContext) Application(i int) IApplicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApplicationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApplicationContext)
}

func (s *Sysl_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sysl_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sysl_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSysl_file(s)
	}
}

func (s *Sysl_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSysl_file(s)
	}
}

func (p *SyslParser) Sysl_file() (localctx ISysl_fileContext) {
	localctx = NewSysl_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SyslParserRULE_sysl_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserIMPORT {
		{
			p.SetState(1654)
			p.Imports_decl()
		}

	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(SyslParserSYSL_COMMENT-60))|(1<<(SyslParserTEXT_LINE-60))|(1<<(SyslParserName-60)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(1657)
			p.Application()
		}

		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1662)
		p.Match(SyslParserEOF)
	}

	return localctx
}

func (p *SyslParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 143:
		var t *Cond_blockContext = nil
		if localctx != nil {
			t = localctx.(*Cond_blockContext)
		}
		return p.Cond_block_Sempred(t, predIndex)

	case 144:
		var t *Final_elseContext = nil
		if localctx != nil {
			t = localctx.(*Final_elseContext)
		}
		return p.Final_else_Sempred(t, predIndex)

	case 155:
		var t *Expr_statementContext = nil
		if localctx != nil {
			t = localctx.(*Expr_statementContext)
		}
		return p.Expr_statement_Sempred(t, predIndex)

	case 169:
		var t *App_declContext = nil
		if localctx != nil {
			t = localctx.(*App_declContext)
		}
		return p.App_decl_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SyslParser) Cond_block_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Final_else_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return localctx.(*Final_elseContext).Get_expr().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Expr_statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return localctx.(*Expr_statementContext).nested == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) App_decl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return localctx.(*App_declContext).check

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
